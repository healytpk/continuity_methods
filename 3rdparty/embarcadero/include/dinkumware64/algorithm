// algorithm standard header
#ifndef _ALGORITHM_
#define _ALGORITHM_
#include <xmemory>
#include <xheap>
#include <xutility>

 #if _HAS_CPP17
#include <xparallel.h>
 #endif /* _HAS_CPP17 */

 #if _HAS_CPP11
#define _TYPE11(ty)	ty
#define _RET11(val)	return (val)

 #else /* HAS_CPP11 */
#define _TYPE11(ty)	void
#define _RET11(val)
 #endif /* HAS_CPP11 */

_STD_BEGIN
 #if _IS_GHS

 #if defined(__GHS_PRAGMAS)
  #pragma ghs start_cxx_lib_header
  #pragma ghs startdata
 #endif /* defined(__GHS_PRAGMAS) */

 #if defined(__ghs_max_pack_value)
  #pragma pack (push, __ghs_max_pack_value)
 #endif /* defined(__ghs_max_pack_value) */

#endif /* _IS_GHS */

		// COMMON SORT PARAMETERS
const int _ISORT_MAX = 32;	// maximum size for insertion sort

		// TEMPLATE FUNCTION for_each
template<class _InIt,
	class _Fn1> inline
	void _For_each(_InIt _First, _InIt _Last, _Fn1& _Func)
	{	// perform function for each element
	for (; _First != _Last; ++_First)
		_Func(*_First);
	}

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	// perform function for each element
	_DEBUG_RANGE_PTR(_First, _Last, _Func);
	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);
	return (_STD move(_Func));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _For_each_payload
template<class _FwdIt,
	class _Fn1>
struct _For_each_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >
	{	// payload for parallel for_each and for_each_n
	typedef _FwdIt _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	template<class _ItOrDiff>
		_For_each_payload(_FwdIt _First, _ItOrDiff _IorD, _Fn1& _F,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _IorD, _Exec), _Func(_F)
		{	// construct with iterator, iterator or size, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		_For_each(_Range._First, _Range._Last, _Func);
		}

	_Fn1& _Func;
	};

		// TEMPLATE FUNCTION _Do_for_each_par
template<class _FwdIt,
	class _ItOrDiff,
	class _Fn1> inline
	_FwdIt _Do_for_each_par(
	_FwdIt _First, _ItOrDiff _IorD, _Fn1& _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _For_each_payload<_FwdIt, _Fn1> _MyPy;
	_MyPy _Payload(_First, _IorD, _Func, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _For_each_par
template<class _FwdIt,
	class _Fn1> inline
	_FwdIt _For_each_par(
	_FwdIt _First, _FwdIt _Last, _Fn1& _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Func);
	return (_Rechecked(_First,
		_Do_for_each_par(_Unchecked(_First), _Unchecked(_Last), _Func, _Exec)));
	}

template<class _InIt,
	class _Fn1> inline
	_InIt _For_each_par(
	_InIt _First, _InIt _Last, _Fn1& _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		_STD for_each(_First, _Last, _Func);
	_CATCH_PAR_END
	return (_First);
	}

		// TEMPLATE FUNCTION PARALLEL for_each
template<class _Policy,
	class _InIt,
	class _Fn1,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_Fn1 for_each(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Fn1 _Func)
	{	// perform function for each element
	_For_each_par(_First, _Last, _Func,
		_GET_POLICY(_First, _Exec));
	return (_Func);
	}
 #endif /* _HAS_CPP17 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION for_each_n
template<class _InIt,
	class _Size,
	class _Fn1> inline
	_InIt _For_each_n(_InIt _First, _Size _Count, _Fn1& _Func)
	{	// perform function for each element
	for (; 0 < _Count; --_Count, (void)++_First)
		_Func(*_First);
	return (_First);
	}

template<class _InIt,
	class _Size,
	class _Fn1> inline
	_InIt for_each_n(_InIt _First, _Size _Count, _Fn1 _Func)
	{	// perform function for _Count elements
	_DEBUG_POINTER_IF(0 <= _Count, _First);
	return (_Rechecked(_First, _For_each_n(_Unchecked(_First), _Count, _Func)));
	}

		// TEMPLATE FUNCTION _For_each_n_par
template<class _FwdIt,
	class _Size,
	class _Fn1> inline
	_FwdIt _For_each_n_par(
	_FwdIt _First, _Size _Count, _Fn1 _Func,
	execution::_Parallel_policy _Exec)
	{	// forward to for_each for parallel execution
	_DEBUG_POINTER_IF(0 <= _Count, _First);
	return (_Rechecked(_First,
		_Do_for_each_par(_Unchecked(_First), _Count, _Func, _Exec)));
	}

template<class _InIt,
	class _Size,
	class _Fn1> inline
	_InIt _For_each_n_par(
	_InIt _First, _Size _Count, _Fn1 _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD for_each_n(_First, _Count, _Func));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL for_each_n
template<class _Policy,
	class _InIt,
	class _Size,
	class _Fn1,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_InIt for_each_n(_Policy&& _Exec,
		_InIt _First, _Size _Count, _Fn1 _Func)
	{	// perform function for _Count elements
	return (_For_each_n_par(_First, _Count, _Func,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION adjacent_find WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred with successor
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				return (_Firstb);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred with successor
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Adjacent_find(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Adjacent_find_pred_payload
template<class _FwdIt,
	class _Pr>
struct _Adjacent_find_pred_payload
	: _Payload_base_single_range<_Overlapping_tiled_range<_FwdIt> >,
		_Init_value_helper<_Tile_result<_FwdIt> >
	{	// payload for parallel adjacent_find with predicate
	typedef _FwdIt _Result_type;
	typedef _Tile_result<_FwdIt> _Tile_result_type;
	typedef _Payload_base_single_range<
		_Overlapping_tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Adjacent_find_pred_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, 1, _Exec),
			_Init_value_helper<_Tile_result_type>(
				_Tile_result_type(_Last, (unsigned int)(-1))),
					_Pred(_Pred_arg)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Adjacent_find(_Range._First, _Range._Last, _Pred),
			_Range._Index);
		return (this->_Maybe_short_circuit(_Res, _Range._Last, _Previous));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res)
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_adjacent_find_pred_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Do_adjacent_find_pred_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Adjacent_find_pred_payload<_FwdIt, _Pr> _Payl;
	_Payl _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_Payl> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Adjacent_find_pred_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find_pred_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First, _Do_adjacent_find_pred_par(
			_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec)));
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find_pred_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD adjacent_find(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL adjacent_find WITH PRED
template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt adjacent_find(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find first satisfying _Pred with successor
	return (_Adjacent_find_pred_par(_First, _Last, _Pred,
			_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION adjacent_find
template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	// find first matching successor
	return (_STD adjacent_find(_First, _Last, _FUNCTOR(equal_to, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt adjacent_find(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// find first matching successor
	return (_STD adjacent_find(_Exec, _First, _Last,
		_FUNCTOR(equal_to, _First)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION count_if
template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// count elements satisfying _Pred
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// count elements satisfying _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Count_if_payload
template<class _FwdIt,
	class _Pr>
struct _Count_if_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
	_Init_value_helper<typename _STD iterator_traits<_FwdIt>::difference_type>
	{	// payload for parallel count_if
	typedef typename std::iterator_traits<_FwdIt>::difference_type _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	template<class _ItOrDiff>
		_Count_if_payload(_FwdIt _First, _ItOrDiff _IorD, _Pr _P,
			execution::_Parallel_policy& _Exec)
				: _Mybase(_First, _IorD, _Exec), _Pred(_P),
		_Init_value_helper<typename _STD iterator_traits<_FwdIt>::difference_type>(0)
		{	// construct with iterator, iterator or size, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		return (_Reduce(_Previous, _Count_if(_Range._First, _Range._Last, _Pred)));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs + _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_count_if_par
template<class _FwdIt,
	class _Pr> inline
	typename iterator_traits<_FwdIt>::difference_type
	_Do_count_if_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Count_if_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Count_if_par
template<class _FwdIt,
	class _Pr> inline
	typename iterator_traits<_FwdIt>::difference_type
	_Count_if_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Do_count_if_par(
		_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec));
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
	_Count_if_par(
	_InIt _First, _InIt _Last, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD count_if(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (0);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL count_if
template<class _Policy,
	class _InIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// count elements satisfying _Pred
	return (_Count_if_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION mismatch WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		{	// point past match
		++_First1;
		++_First2;
		}
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, true_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, false_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Pred);
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch2(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred, _Is_checked(_First2)));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize], _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(
		_STD mismatch(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	return (pair<_InIt1, _InTy *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Mismatch_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
struct _Mismatch_payload
	: _Payload_base_dual_range<_Tiled_range<_FwdIt1>, _Tiled_range<_FwdIt2> >,
		_Init_value_helper<_Tile_result<pair<_FwdIt1, _FwdIt2> > >
	{	// payload for parallel mismatch
	typedef pair<_FwdIt1, _FwdIt2> _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>, _Tiled_range<_FwdIt2> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Mismatch_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, std::distance(_First1, _Last1), _First2, _Exec),
			_Init_value_helper<_Tile_result<pair<_FwdIt1, _FwdIt2> > >(
				_Tile_result_type(_Result_type(
					_Last1, _Mybase::_End()), (unsigned int)(-1))),
						_Pred(_Pred_arg)
		{	// construct wtih iterator pair, iterator, predicate, and policy
		}

	_Mismatch_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred_arg,
			execution::_Parallel_policy& _Exec)
		: _Mybase(_First1,
			_Lesser(std::distance(_First1, _Last1),
				std::distance(_First2, _Last2)),
					_First2, _Exec),
		_Init_value_helper<_Tile_result_type>(_Tile_result_type(
			_Result_type(_Last1, _Last2), (unsigned int)(-1))),
				_Pred(_Pred_arg)
		{	// construct with two iterator pairs, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Mismatch(_Range._First1, _Range._Last1, _Range._First2, _Pred),
			_Range._Index);
		if (_Res._Value.first == _Range._Last1 && _Res._Value.second == _Range._Last2)
			_Res = _Previous;
		else
			this->_Set_short_circuit();
		return (_Res);
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_mismatch_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	pair<_FwdIt1, _FwdIt2>
	_Do_mismatch_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Mismatch_payload<_FwdIt1, _FwdIt2, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Mismatch_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	pair<_FwdIt1, _FwdIt2>
	_Mismatch_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Pred);
	pair<_UNCHECKED_TYPE(_FwdIt1), _UNCHECKED_TYPE(_FwdIt2)> _Ans(
		_Do_mismatch_par(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Pred, _Exec));
	return (pair<_FwdIt1, _FwdIt2>(
		_Rechecked(_First1, _Ans.first),
		_Rechecked(_First2, _Ans.second)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
	_Mismatch_par(
	_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD mismatch(_First1, _Last1, _First2, _Pred));
	_CATCH_PAR_END
	return (pair<_InIt1, _InIt2>(_First1, _Last1));	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_InIt1, _InIt2>
		mismatch(_Policy&& _Exec,
			_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	return (_Mismatch_par(_First1, _Last1, _First2, _Pred,
		_GET_POLICY2(_First1, _First2, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION mismatch
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	return (_STD mismatch(_First1, _Last1, _First2,
		_FUNCTOR(equal_to, _First1)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize])
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array input
	return (_STD mismatch(_First1, _Last1, _First2,
		_FUNCTOR(equal_to, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_InIt1, _InIt2>
		mismatch(_Policy&& _Exec,
			_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	return (_Mismatch_par(_First1, _Last1, _First2,
		_FUNCTOR(equal_to, _First1),
		_GET_POLICY2(_First1, _First2, _Exec)));
	}
 #endif /* _HAS_CPP17 */

 #if _HAS_CPP14
		// TEMPLATE FUNCTION mismatch WITH TWO RANGES, PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2
		&& _Pred(*_First1, *_First2); )
		{	// point past match
		++_First1;
		++_First2;
		}
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER_IF(_First1 != _Last1 && _First2 != _Last2, _Pred);
	pair<_UNCHECKED_TYPE(_InIt1), _UNCHECKED_TYPE(_InIt2)> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Rechecked(_First2, _Ans.second)));
	}

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Mismatch_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	pair<_FwdIt1, _FwdIt2>
	_Do_mismatch_par2(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
	_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Mismatch_payload<_FwdIt1, _FwdIt2, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Last2, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	pair<_FwdIt1, _FwdIt2>
	_Mismatch_par2(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER_IF(_First1 != _Last1 && _First2 != _Last2, _Pred);
	pair<_UNCHECKED_TYPE(_FwdIt1), _UNCHECKED_TYPE(_FwdIt2)> _Ans(
		_Do_mismatch_par2(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred, _Exec));
	return (pair<_FwdIt1, _FwdIt2>(
		_Rechecked(_First1, _Ans.first),
		_Rechecked(_First2, _Ans.second)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
	_Mismatch_par2(
	_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD mismatch(_First1, _Last1, _First2, _Pred));
	_CATCH_PAR_END
	return (pair<_InIt1, _InIt2>(_First1, _Last1));	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_InIt1, _InIt2>
		mismatch(_Policy&& _Exec,
			_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch using _Pred
	return (_Mismatch_par2(_First1, _Last1, _First2, _Last2, _Pred,
		_GET_POLICY2(_First1, _First2, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION mismatch WITH TWO RANGES
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch
	return (_STD mismatch(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_InIt1, _InIt2>
		mismatch(_Policy&& _Exec,
			_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2)
	{	// return [_First1, _Last1)/[_First2, _Last2) mismatch
	return (_Mismatch_par2(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1),
		_GET_POLICY2(_First1, _First2, _Exec)));
	}
 #endif /* _HAS_CPP17 */

 #endif /* _HAS_CPP14 */

 #if _HAS_CPP11
		// TEMPLATE FUNCTION all_of
template<class _InIt,
	class _Pr> inline
	bool _All_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_All_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _All_of_payload
template<class _FwdIt,
	class _Pr>
struct _All_of_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
	_Init_value_helper<bool>
	{	// payload for parallel all_of
	typedef bool _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_All_of_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec), _Pred(_Pred_arg),
			_Init_value_helper<bool>(true)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res =
			_Reduce(_Previous, _All_of(_Range._First, _Range._Last, _Pred));
		return (this->_Maybe_short_circuit(_Res, true, _Res));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs && _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res)
		{	// extract result
		return _Res;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_all_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _Do_all_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _All_of_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _All_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _All_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Do_all_of_par(_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec));
	}

template<class _InIt,
	class _Pr> inline
	bool _All_of_par(
	_InIt _First, _InIt _Last, _Pr _Pred,
	execution::sequenced_policy _Exec)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD all_of(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (false);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL all_of
template<class _Policy,
	class _InIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool all_of(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	return (_All_of_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION any_of
template<class _InIt,
	class _Pr> inline
	bool _Any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if any element satisfies _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (true);
	return (false);
	}

template<class _InIt,
	class _Pr> inline
	bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if any element satisfies _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Any_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Any_of_payload
template<class _FwdIt,
	class _Pr>
struct _Any_of_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
	_Init_value_helper<bool>
	{	// payload for parallel any_of
	typedef bool _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Any_of_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec), _Pred(_Pred_arg),
			_Init_value_helper<bool>(false)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res =
			_Reduce(_Previous, _Any_of(_Range._First, _Range._Last, _Pred));
		return (this->_Maybe_short_circuit(_Res, false, _Res));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs || _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_any_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _Do_any_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Any_of_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Any_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _Any_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Do_any_of_par(
		_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec));
	}

template<class _InIt,
	class _Pr> inline
	bool _Any_of_par(
	_InIt _First, _InIt _Last, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD any_of(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (false);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL any_of
template<class _Policy,
	class _InIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool any_of(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if all elements satisfy _Pred
	return (_Any_of_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION none_of
template<class _InIt,
	class _Pr> inline
	bool _None_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_None_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _None_of_payload
template<class _FwdIt,
	class _Pr>
struct _None_of_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
	_Init_value_helper<bool>
	{	// payload for parallel none_of
	typedef bool _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_None_of_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
			_Init_value_helper<bool>(true),
				_Pred(_Pred_arg)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res =
			_Reduce(_Previous, _None_of(_Range._First, _Range._Last, _Pred));
		return (this->_Maybe_short_circuit(_Res, false, _Res));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs && _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_none_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _Do_none_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _None_of_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _None_of_par
template<class _FwdIt,
	class _Pr> inline
	bool _None_of_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Do_none_of_par(
		_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec));
	}

template<class _InIt,
	class _Pr> inline
	bool _None_of_par(
	_InIt _First, _InIt _Last, _Pr _Pred,
	execution::sequenced_policy _Exec)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD none_of(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (false);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL none_of
template<class _Policy,
	class _InIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool none_of(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if no elements satisfy _Pred
	return (_None_of_par(_First, _Last, _Pred, _GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION find_if_not
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Find_if_not_payload
template<class _FwdIt,
	class _Pr>
struct _Find_if_not_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
		_Init_value_helper<_Tile_result<_FwdIt> >
	{	// payload for parallel find_if_not
	typedef _FwdIt _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Find_if_not_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
			_Init_value_helper<_Tile_result<_FwdIt> >(
				_Tile_result_type(_Last, (unsigned int)(-1))),
					_Pred(_Pred_arg)
		{	// construct from iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Find_if_not(_Range._First, _Range._Last, _Pred),
			_Range._Index);
		return (this->_Maybe_short_circuit(_Res, _Range._Last, _Previous));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_find_if_not_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Do_find_if_not_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Find_if_not_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Find_if_not_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Find_if_not_par(
	_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
			_Do_find_if_not_par(
				_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec)));
	}

template<class _RanIt,
	class _Pr> inline
	_RanIt _Find_if_not_par(
	_RanIt _First, _RanIt _Last, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD find_if_not(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL find_if_not
template<class _Policy,
	class _InIt,
	class _Pr,
	class = typename enable_if<is_execution_policy<decay_t<_Policy> >::value,
		void>::type> inline
	_InIt find_if_not(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// find first element that satisfies !_Pred
	return (_Find_if_not_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION partition_copy
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	// validate _Dest1 and store
			_DEBUG_POINTER(_Dest1);
			*_Dest1++ = *_First;
			}
		else
			{	// validate _Dest2 and store
			_DEBUG_POINTER(_Dest2);
			*_Dest2++ = *_First;
			}
	return (pair<_OutIt1, _OutIt2>( _Dest1, _Dest2));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			true_type, true_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, checked dest
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			true_type, false_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			false_type, true_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred,
			false_type, false_type)
	{	// copy true partition *_Dest1++, false to *_Dest2++, unchecked dest
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_First, _Last,
			_Dest1, _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (pair<_OutIt1, _OutIt2>(
		_Partition_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest1, _Dest2, _Pred,
			_Is_checked(_Dest1), _Is_checked(_Dest2))));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutTy1 *, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	pair<_Array_iterator<_OutTy1, _OutSize1>, _OutIt2> _Ans =
		_STD partition_copy(_First, _Last,
			_Array_iterator<_OutTy1, _OutSize1>(_Dest1), _Dest2, _Pred);
	return (pair<_OutTy1 *, _OutIt2>(
		_Unchecked(_Ans.first),
		_Ans.second));
	}

template<class _InIt,
	class _OutIt1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutIt1, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutTy2 (&_Dest2)[_OutSize2], _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	pair<_OutIt1, _Array_iterator<_OutTy2, _OutSize2> > _Ans =
		_STD partition_copy(_First, _Last,
			_Dest1, _Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (pair<_OutIt1, _OutTy2 *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutTy1 *, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutTy2 (&_Dest2)[_OutSize2],
			_Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++, array dest
	pair<_Array_iterator<_OutTy1, _OutSize1>,
		_Array_iterator<_OutTy2, _OutSize2> > _Ans =
			_STD partition_copy(_First, _Last,
				_Array_iterator<_OutTy1, _OutSize1>(_Dest1),
				_Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred);
	return (pair<_OutTy1 *, _OutTy2 *>(
		_Unchecked(_Ans.first),
		_Unchecked(_Ans.second)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
template<class _Policy,
	class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
	partition_copy(_Policy&& _Exec,
		_InIt _First, _InIt _Last,
		_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	// copy true partition *_Dest1++, false to *_Dest2++
	return (partition_copy(_First, _Last, _Dest1, _Dest2, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION is_partitioned
template<class _InIt,
	class _Pr> inline
	bool _Is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			{	// skip true partition
			++_First;
			break;
			}
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);	// found out of place element
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Is_partitioned(_Unchecked(_First), _Unchecked(_Last),
		_Pred));
	}

 #if _HAS_CPP17
struct _Partition_data
	{	// struct that holds partial results for is_partitioned
	_Partition_data(int _Idx = -1)
		: _Status(_Unknown), _Index(_Idx)
		{	// construct in unknown state with index
		}

	enum _Partition_status
		{	// potential states for partition data
		_All_less,
		_All_greater,
		_Partitioned,
		_Not_partitioned,
		_Dual,
		_Unknown
		} _Status;
	int _Index;
	int _Rindex;
	};

template<class _FwdIt,
	class _Pr>
	struct _Is_partitioned_payload
		: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
			_Init_value_helper<_Partition_data>
	{	// payload for parallel is_partitioned
	typedef bool _Result_type;
	typedef _Partition_data _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Is_partitioned_payload(_FwdIt _First, _FwdIt _Last, _Pr _Pred_arg,
		execution::_Parallel_policy& _Exec)
			: _Mybase(_First, _Last, _Exec),
				_Init_value_helper<_Partition_data>(_Partition_data()),
					_Pred(_Pred_arg)
		{	// construct from single range
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// check partitioning of subrange
		_Tile_result_type _Res(_Range._Index);
		_FwdIt _First1 = _Range._First;
		for (; _First1 != _Range._Last && _Pred(*_First1); ++_First1)
			;	// nothing to do
		if (_First1 == _Range._Last)
			{	// all elements satisfy predicate
			_Res._Status = _Partition_data::_All_less;
			return (_Reduce(_Res, _Previous));
			}
		_FwdIt _First2 = std::next(_First1);
		for (; _First2 != _Range._Last && !_Pred(*_First2); ++_First2)
			;	// nothing to do
		if (_First2 != _Range._Last)
			{	// found element out of order
			_Res._Status = _Partition_data::_Not_partitioned;
			this->_Set_short_circuit();
			return (_Reduce(_Res, _Previous));
			}
		else if (_First1 == _Range._First)
			{	// no elements satisfy predicate
			_Res._Status = _Partition_data::_All_greater;
			return (_Reduce(_Res, _Previous));
			}
		else
			{	// partition point is inside the range
			_Res._Status = _Partition_data::_Partitioned;
			return (_Reduce(_Res, _Previous));
			}
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine results from subranges
		_Tile_result_type _Res(-1);
		if (_Rhs._Index < _Lhs._Index)
			std::swap(_Lhs, _Rhs);
		if (_Lhs._Status == _Partition_data::_Not_partitioned
			|| _Rhs._Status == _Partition_data::_Not_partitioned)
			_Res._Status = _Partition_data::_Not_partitioned;
		else if (_Lhs._Status == _Partition_data::_Unknown)
			_Res = _Rhs;
		else if (_Rhs._Status == _Partition_data::_Unknown)
			_Res = _Lhs;
		else if (_Lhs._Status == _Partition_data::_All_less)
			switch(_Rhs._Status)
				{	// combine results when _Lhs status is _All_less
			case _Partition_data::_All_less:
				_Res = _Rhs;
				break;

			case _Partition_data::_All_greater:
				_Res._Status = _Partition_data::_Dual;
				_Res._Index = _Lhs._Index;
				_Res._Rindex = _Rhs._Index;
				break;

			case _Partition_data::_Partitioned:
			case _Partition_data::_Dual:
				_Res = _Rhs;
				break;

			default:
				// quiet warning
				break;
				}
		else if (_Lhs._Status == _Partition_data::_All_greater)
			if (_Rhs._Status == _Partition_data::_All_greater)
				_Res = _Lhs;
			else
				{	// _Lhs is above _Rhs, so no possible intersection
				_Res._Status = _Partition_data::_Not_partitioned;
				this->_Set_short_circuit();
				}
		else if (_Lhs._Status == _Partition_data::_Partitioned)
			if (_Rhs._Status == _Partition_data::_All_greater)
				_Res = _Lhs;
			else
				{
				_Res._Status = _Partition_data::_Not_partitioned;
				this->_Set_short_circuit();
				}
		else if (_Lhs._Status == _Partition_data::_Dual)
			switch(_Rhs._Status)
				{	// intersect with dual range
			case _Partition_data::_All_less:
				if (_Lhs._Rindex < _Rhs._Index)
					{	// _Rhs above dual range; intersection is empty
					_Res._Status = _Partition_data::_Not_partitioned;
					this->_Set_short_circuit();
					}
				else
					{	// _Rhs inside dual range; set _Res to intersection
					_Res._Status = _Partition_data::_Dual;
					_Res._Index = _Rhs._Index;
					_Res._Rindex = _Lhs._Rindex;
					}
				break;

			case _Partition_data::_All_greater:
				_Res._Status = _Partition_data::_Dual;
				_Res._Index = _Lhs._Index;
				_Res._Rindex = _Lhs._Rindex < _Rhs._Index
					? _Lhs._Rindex : _Rhs._Index;
				break;

			case _Partition_data::_Partitioned:
				if (_Rhs._Index < _Lhs._Rindex)
					_Res = _Rhs;
				else
					{	// _Rhs outside dual range; intersection is empty
					_Res._Status = _Partition_data::_Not_partitioned;
					this->_Set_short_circuit();
					}
				break;

			case _Partition_data::_Dual:
				if (_Rhs._Rindex < _Lhs._Index
					|| _Lhs._Rindex < _Rhs._Index)
					{	// non-overlapping duals; intersection is empty
					_Res._Status = _Partition_data::_Not_partitioned;
					this->_Set_short_circuit();
					}
				else
					{	// overlapping duals; set _Res to intersection
					_Res._Status = _Partition_data::_Dual;
					_Res._Index = _Rhs._Index;
					_Res._Rindex = _Lhs._Rindex < _Rhs._Rindex
						? _Lhs._Rindex : _Rhs._Rindex;
					}
				break;

				default:
				break;	// quiet warning
				}
			return (_Res);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		switch(_Res._Status)
			{
		case _Partition_data::_All_less:
			return (_Res._Index == _Mybase::_Ntiles - 1);

		case _Partition_data::_All_greater:
			return (_Res._Index == 0);

		case _Partition_data::_Partitioned:
			return (true);

		case _Partition_data::_Dual:
			return (_Res._Index == _Res._Rindex - 1);

		default:
			return (false);
			}
		}

private:
	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_is_partitioned_par
template<class _FwdIt,
	class _Pr> inline
	bool _Do_is_partitioned_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
			execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Is_partitioned_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Is_partitioned_par
template<class _FwdIt,
	class _Pr>
	bool _Is_partitioned_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
			execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Do_is_partitioned_par(_Unchecked(_First), _Unchecked(_Last),
			_Pred, _Exec));
	}

template<class _InIt,
	class _Pr>
	bool _Is_partitioned_par(
		_InIt _First, _InIt _Last, _Pr _Pred,
			execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD is_partitioned(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (false);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool is_partitioned(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _Pr _Pred)
	{	// test if [_First, _Last) partitioned by _Pred
	return (_Is_partitioned_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION partition_point
template<class _FwdIt,
	class _Diff,
	class _Pr> inline
	_FwdIt _Partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred, _Diff *)
	{	// find beginning of false partition in [_First, _Last)
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	while (0 < _Count)
		{	// divide and conquer, find half that contains answer
		_Diff _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		_STD advance(_Mid, _Count2);

		if (_Pred(*_Mid))
			{	// try top half
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find beginning of false partition in [_First, _Last)
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Partition_point(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}
 #endif /* _HAS_CPP11 */

		// TEMPLATE FUNCTION search_n WITH PRED
template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
	{	// find first _Count * _Val satisfying _Pred, forward iterators
	if (_Count <= 0)
		return (_First);

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			{	// found start of possible match, check it out
			_FwdIt _Mid = _First;

			for (uintmax_t _Count1 = _Count; ; )
				if (--_Count1 == 0)
					return (_First);	// found rest of match, report it
				else if (++_Mid == _Last)
					return (_Last);	// short match at end
				else if (!_Pred(*_Mid, _Val))
					{	// short match not at end
					break;
					}

			_First = _Mid;	// pick up just beyond failed match
			}
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
	{	// find first _Count * _Val satisfying _Pred, random-access iterators
	if (_Count <= 0)
		return (_First);

	_FwdIt _Oldfirst = _First;
	for (uintmax_t _Inc = 0; _Count <= _Last - _Oldfirst; )
		{	// enough room, look for a match
		_First = _Oldfirst + _Inc;
		if (_Pred(*_First, _Val))
			{	// found part of possible match, check it out
			uintmax_t _Count1 = _Count;
			_FwdIt _Mid = _First;

			for (; _Oldfirst != _First && _Pred(_First[-1], _Val);
				--_First)
				--_Count1;	// back up over any skipped prefix

			if (_Count1 <= _Last - _Mid)
				for (; ; )
					{	// enough left, test suffix
					if (--_Count1 == 0)
						return (_First);	// found rest of match, report it
					else if (!_Pred(*++_Mid, _Val))
						{	// short match not at end
						break;
						}
					}
			_Oldfirst = ++_Mid;	// failed match, take small jump
			_Inc = 0;
			}
		else
			{	// no match, take big jump and back up as needed
			_Oldfirst = _First + 1;
			_Inc = _Count - 1;
			}
		}
	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred)
	{	// find first _Count * _Val satisfying _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Search_n(_Unchecked(_First), _Unchecked(_Last), _Count, _Val,
			_Pred, _Iter_cat(_First))));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Search_n_payload
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr>
struct _Search_n_payload
	: _Payload_base_single_range<_Overlapping_tiled_range<_RanIt> >,
		_Init_value_helper<_Tile_result<_RanIt> >
	{	// payload for parallel search_n
	typedef _RanIt _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<
		_Overlapping_tiled_range<_RanIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Search_n_payload(_RanIt _First, _RanIt _Last,
		_Diff _C, const _Ty& _V, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _C, _Exec),
			_Init_value_helper<_Tile_result<_RanIt> >(
				_Tile_result_type(_Last, (unsigned int)(-1))),
					_Val(_V), _Count(_C), _Pred(_P)
		{	// construct with iterator pair, count, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Search_n(_Range._First, _Range._Last, _Count, _Val, _Pred,
				_Iter_cat(_Range._First)),
			_Range._Index);
		return (this->_Maybe_short_circuit(_Res, _Range._Last, _Previous));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	const _Ty& _Val;
	const _Diff _Count;
	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_search_n_par
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Do_search_n_par(
	_RanIt _First, _RanIt _Last, _Diff _Count, const _Ty& _Val, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Search_n_payload<_RanIt, _Diff, _Ty, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Count, _Val, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Search_n_par
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Search_n_par(
	_RanIt _First, _RanIt _Last, _Diff _Count, const _Ty& _Val, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Do_search_n_par(_Unchecked(_First), _Unchecked(_Last),
		_Count, _Val, _Pred, _Exec)));
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n_par(
	_FwdIt _First, _FwdIt _Last, _Diff _Count, const _Ty& _Val, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD search_n(_First, _Last, _Count, _Val, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt search_n(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred)
	{	// find first _Count * _Val satisfying _Pred
	return (_Search_n_par(_First, _Last, _Count, _Val, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION search_n
template<class _FwdIt,
	class _Diff,
	class _Ty> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val)
	{	// find first _Count * _Val match
	return (_STD search_n(_First, _Last, _Count, _Val,
		_FUNCTOR(equal_to, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class _Diff,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt search_n(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val)
	{	// find first _Count * _Val
	return (_STD search_n(_Exec, _First, _Last, _Count, _Val,
		_FUNCTOR(equal_to, _First)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION find_end WITH PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff1,
	class _Diff2,
	class _Pr> inline
	_FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
	{	// find last [_First2, _Last2) satisfying _Pred
	_Diff1 _Count1 = 0;
	_Distance(_First1, _Last1, _Count1);
	_Diff2 _Count2 = 0;
	_Distance(_First2, _Last2, _Count2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		{	// validate _Pred and test
		_DEBUG_POINTER_IF(_Count2 <= _Count1, _Pred);
		for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
			{	// room for match, try it
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!_Pred(*_Mid1, *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	// potential answer, save it
					_Ans = _First1;
					break;
					}
			}
		}
	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// find last [_First2, _Last2) satisfying _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Rechecked(_First1,
		_Find_end(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Dist_type(_First1), _Dist_type(_First2))));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Find_end_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
struct _Find_end_payload
	: _Payload_base_dual_range<_Overlapping_tiled_range<_FwdIt1>,
		_Untiled_range<_FwdIt2> >,
	_Init_value_helper<_Tile_result<_FwdIt1> >
	{	// payload for parallel find_end
	typedef _FwdIt1 _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_dual_range<_Overlapping_tiled_range<_FwdIt1>,
	_Untiled_range<_FwdIt2> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Find_end_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2,
		_Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _Last2,
			std::distance(_First2, _Last2), _Exec),
			_Init_value_helper<_Tile_result<_FwdIt1> >(
				_Tile_result_type(_Last1, (unsigned int)(-1))), _Pred(_P)
		{	// construct from two iterator pairs, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Find_end(_Range._First1, _Range._Last1, _Range._First2, _Range._Last2, _Pred,
			_Dist_type(_Range._First1), _Dist_type(_Range._First2)),
			_Range._Index);
		if (_Res._Value == _Range._Last1)
			_Res = _Previous;
		return (_Res);
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index == (unsigned int)(-1) ? _Rhs
			: _Rhs._Index == (unsigned int)(-1) ? _Lhs
			: _Lhs._Index <= _Rhs._Index ? _Rhs : _Lhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_find_end_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Do_find_end_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Find_end_payload<_FwdIt1, _FwdIt2, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Last2, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Find_end_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_end_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER_IF(_First1 != _Last1 && _First2 != _Last2, _Pred);
	return (_Rechecked(_First1,
		_Do_find_end_par(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred, _Exec)));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_end_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD find_end(_First1, _Last1, _First2, _Last2, _Pred));
	_CATCH_PAR_END
	return (_First1);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt1 find_end(_Policy&& _Exec,
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// find last [_First2, _Last2) satisfying _Pred
	return (_Find_end_par(_First1, _Last1, _First2, _Last2, _Pred,
		_GET_POLICY2(_First1, _First2, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION find_end
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// find last [_First2, _Last2) match
	return (_STD find_end(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt1,
	class _FwdIt2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt1 find_end(_Policy&& _Exec,
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// find last [_First2, _Last2) match
	return (_STD find_end(_Exec, _First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION find_first_of WITH PRED
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// look for one of [_First2, _Last2) satisfying _Pred with element
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (_Pred(*_First1, *_Mid2))
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// look for one of [_First2, _Last2) satisfying _Pred with element
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER_IF(_First1 != _Last1 && _First2 != _Last2, _Pred);
	return (_Rechecked(_First1,
		_Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Find_first_of_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
struct _Find_first_of_payload
	: _Payload_base_dual_range<_Tiled_range<_FwdIt1>,
		_Untiled_range<_FwdIt2> >,
		_Init_value_helper<_Tile_result<_FwdIt1> >
	{	// payload for parallel find_first_of
	typedef _FwdIt1 _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>, _Untiled_range<_FwdIt2> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Find_first_of_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _Last2, _Exec),
			_Init_value_helper<_Tile_result<_FwdIt1> >(
				_Tile_result_type(_Last1, (unsigned int)(-1))), _Pred(_P)
		{	// construct with two iterator pairs, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Find_first_of(_Range._First1, _Range._Last1,
				_Range._First2, _Range._Last2, _Pred),
			_Range._Index);
		return (this->_Maybe_short_circuit(_Res, _Range._Last1, _Previous));
		}

	static _Tile_result_type
	_Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_find_first_of_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Do_find_first_of_par(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Find_first_of_payload<_FwdIt1, _FwdIt2, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Last2, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Find_first_of_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of_par(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER_IF(_First1 != _Last1 && _First2 != _Last2, _Pred);
	return (_Rechecked(_First1,
			_Do_find_first_of_par(_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2), _Pred, _Exec)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	_InIt1 _Find_first_of_par(
	_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD find_first_of(_First1, _Last1, _First2, _Last2, _Pred));
	_CATCH_PAR_END
	return (_First1);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL find_first_of WITH PRED
template<class _Policy,
	class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt1 find_first_of(_Policy&& _Exec,
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	// look for one of [_First2, _Last2) satisfying _Pred with element
	return (_Find_first_of_par(_First1, _Last1, _First2, _Last2, _Pred,
		_Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION find_first_of
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// look for one of [_First2, _Last2) that matches element
	return (_STD find_first_of(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt1,
	class _FwdIt2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt1 find_first_of(_Policy&& _Exec,
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	// look for one of [_First2, _Last2) that matches element
	return (_Find_first_of_par(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(equal_to, _First1),
		_Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION transform WITH UNARY OP
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = _Func(*_First);
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	return (_Transform(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Func));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// transform [_First, _Last) with _Func, arbitrary iterators
	return (_Transform(_First, _Last,
		_Dest, _Func));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First, _Last) with _Func, random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Transform(_First, _Last,
		_Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, true_type)
	{	// transform [_First, _Last) with _Func, checked dest
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func, false_type)
	{	// transform [_First, _Last) with _Func, unchecked dest
	return (_Transform1(_First, _Last,
		_Dest, _Func,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	_DEBUG_POINTER_IF(_First != _Last, _Func);
	return (_Transform1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Func, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Fn1> inline
	_OutTy *transform(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Fn1 _Func)
	{	// transform [_First, _Last) with _Func, array dest
	return (_Unchecked(
		_STD transform(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Transform_unary_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Fn1>
struct _Transform_unary_payload
	: _Payload_base_dual_range<_Tiled_range<_FwdIt1>, _Tiled_range<_FwdIt2> >
	{	// payload for parallel unary transform
	typedef _FwdIt2 _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>, _Tiled_range<_FwdIt2> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Transform_unary_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Fn1& _F,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _Exec), _Func1(_F)
		{	// constructn with iterator pair, iterator, function, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		transform(_Range._First1, _Range._Last1, _Range._First2, _Func1);
		}

	_Fn1& _Func1;
	};

		// TEMPLATE FUNCTION _Do_transform_unary_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Fn1> inline
	_FwdIt2 _Do_transform_unary_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Fn1& _Func1,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Transform_unary_payload<_FwdIt1, _FwdIt2, _Fn1> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Func1, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Transform_unary_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Fn1> inline
	_FwdIt2 _Transform_unary_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Fn1& _Func1,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Func1);
	return (_Rechecked(_First2,
		_Do_transform_unary_par(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Func1, _Exec)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_unary_par(
	_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1& _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD transform(_First, _Last, _Dest, _Func));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL transform WITH UNARY OP
template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Fn1,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt transform(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest, _Fn1 _Func)
	{	// transform [_First, _Last) with _Func
	return (_Transform_unary_par(_First, _Last, _Dest, _Func,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION transform WITH BINARY OP
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	for (; _First1 != _Last1; ++_First1, (void)++_First2, ++_Dest)
		*_Dest = _Func(*_First1, *_First2);
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	return (_Transform(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Dest, _Func));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), arbitrary dest
	return (_Transform(_First1, _Last1,
		_First2, _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform3(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), random-access dest
	_OutIt _Ans = _Dest + (_Last1 - _First1);	// also checks range
	_Transform(_First1, _Last1,
		_First2, _Unchecked(_Dest), _Func);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		input_iterator_tag, input_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), arbitrary input
	return (_Transform3(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// transform [_First1, _Last1) and [_First2, ...), random-access input
	_InIt2 _Last2 = _First2 + (_Last1 - _First1);	// also checks range
	_Last2 = _Last2;	// to quiet diagnostics
	return (_Transform3(_First1, _Last1,
		_Unchecked(_First2), _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		true_type)
	{	// transform [_First1, _Last1) and [_First2, ...), checked dest
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func,
		false_type)
	{	// transform [_First1, _Last1) and [_First2, ...), unchecked dest
	return (_Transform2(_First1, _Last1,
		_First2, _Dest, _Func,
		_Iter_cat(_First1), _Iter_cat(_First2)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Dest);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Func);
	return (_Transform2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Dest, _Func,
		_Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array input
	return (_STD transform(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_First2, _Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...), array input/dest
	return (_Unchecked(
		_STD transform(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2),
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Transform_binary_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Fn2>
struct _Transform_binary_payload
	: _Payload_base_triple_range<_Tiled_range<_FwdIt1>, _Tiled_range<_FwdIt2>,
	_Tiled_range<_FwdIt3> >
	{	// payload for parallel binary transform
	typedef _FwdIt3 _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_triple_range<
		_Tiled_range<_FwdIt1>,
		_Tiled_range<_FwdIt2>,
		_Tiled_range<_FwdIt3> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Transform_binary_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt3 _First3, _Fn2& _F,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _First3, _Exec), _Func(_F)
		{	// construct with iterator pair, two iterators, function, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		_Transform(_Range._First1, _Range._Last1,
			_Range._First2, _Range._First3, _Func);
		}

	_Fn2& _Func;
	};

		// TEMPLATE FUNCTION _Do_transform_binary_par
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Fn1> inline
	_FwdIt3 _Do_transform_binary_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
	_FwdIt3 _First3, _Fn1& _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Transform_binary_payload<_FwdIt1, _FwdIt2, _FwdIt3, _Fn1> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _First3, _Func, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Transform_binary_par
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Fn1> inline
	_FwdIt3 _Transform_binary_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt3 _First3, _Fn1& _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Transform_binary_payload<_FwdIt1, _FwdIt2, _FwdIt3, _Fn1> _MyPy;
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	_DEBUG_POINTER_IF(_First1 != _Last1, _First3);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Func);
	return (_Rechecked(_First3,
	_Do_transform_binary_par(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_First3),
		_Func, _Exec)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_binary_par(
	_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _OutIt _Dest, _Fn1& _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD transform(_First1, _Last1, _First2, _Dest, _Func));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL transform WITH BINARY OP
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt transform(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	// transform [_First1, _Last1) and [_First2, ...) with _Func
	return (_Transform_binary_par(_First1, _Last1, _First2, _Dest, _Func,
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION replace
template<class _FwdIt,
	class _Ty> inline
	void _Replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	// replace each matching _Oldval with _Newval
	for (; _First != _Last; ++_First)
		if (*_First == _Oldval)
			*_First = _Newval;
	}

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	// replace each matching _Oldval with _Newval
	_DEBUG_RANGE(_First, _Last);
	_Replace(_Unchecked(_First), _Unchecked(_Last),
		_Oldval, _Newval);
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Replace_payload
template<class _FwdIt,
	class _Ty>
struct _Replace_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >
	{	// payload for parallel replace
	typedef _FwdIt _Result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Replace_payload(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val1, const _Ty& _Val2,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
		_Oldval(_Val1), _Newval(_Val2)
		{	// construct with iterator pair, two values, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		_Replace(_Range._First, _Range._Last, _Oldval, _Newval);
		}

	const _Ty& _Oldval;
	const _Ty& _Newval;
	};

		// TEMPLATE FUNCTION _Do_replace_par
template<class _FwdIt,
	class _Ty> inline
	void _Do_replace_par(
	_FwdIt _First, _FwdIt _Last,
	const _Ty& _Oldval, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Replace_payload<_FwdIt, _Ty> _MyPy;
	_MyPy _Payload(_First, _Last, _Oldval, _Newval, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	}

		// TEMPLATE FUNCTION _Replace_par
template<class _FwdIt,
	class _Ty> inline
	void _Replace_par(
	_FwdIt _First, _FwdIt _Last,
	const _Ty& _Oldval, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_Do_replace_par(_Unchecked(_First), _Unchecked(_Last), _Oldval, _Newval, _Exec);
	}

template<class _InIt,
	class _Ty> inline
	void _Replace_par(
	_InIt _First, _InIt _Last,
	const _Ty& _Oldval, const _Ty& _Newval,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		_STD replace(_First, _Last, _Oldval, _Newval);
	_CATCH_PAR_END
	}

		// TEMPLATE FUNCTION PARALLEL replace
template<class _Policy,
	class _FwdIt,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void replace(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	// replace each matching _Oldval with _Newval
	_Replace_par(_First, _Last, _Oldval, _Newval,
		_GET_POLICY(_First, _Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION replace_if
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	// replace each satisfying _Pred with _Val
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_First = _Val;
	}

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	// replace each satisfying _Pred with _Val
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	_Replace_if(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Val);
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Replace_if_payload
template<class _FwdIt,
	class _Pr,
	class _Ty>
struct _Replace_if_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >
	{	// payload for parallel replace_if
	typedef _FwdIt _Result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Replace_if_payload(_FwdIt _First, _FwdIt _Last,
		_Pr _P, const _Ty& _New,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
		_Pred(_P), _Newval(_New)
		{	// construct with iterator pair, predicate, value, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		std::replace_if(_Range._First, _Range._Last, _Pred, _Newval);
		}

	_Pr _Pred;
	const _Ty& _Newval;
	};

		// TEMPLATE FUNCTION _Do_replace_if_par
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Do_replace_if_par(
	_FwdIt _First, _FwdIt _Last,
	_Pr _Pred, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Replace_if_payload<_FwdIt, _Pr, _Ty> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Newval, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	}

		// TEMPLATE FUNCTION _Replace_if_par
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if_par(
	_FwdIt _First, _FwdIt _Last,
	_Pr _Pred, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	_Do_replace_if_par(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Newval, _Exec);
	}

template<class _InIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if_par(
	_InIt _First, _InIt _Last,
	_Pr _Pred, const _Ty& _Newval,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		_STD replace_if(_First, _Last, _Pred, _Newval);
	_CATCH_PAR_END
	}

		// TEMPLATE FUNCTION PARALLEL replace_if
template<class _Policy,
	class _FwdIt,
	class _Pr,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void replace_if(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last,
		_Pr _Pred, const _Ty& _Val)
	{	// replace each satisfying _Pred with _Val
	_Replace_if_par(_First, _Last, _Pred, _Val, _GET_POLICY(_First, _Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION replace_copy
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	for (; _First != _Last; ++_First, (void)++_Dest)
		if (*_First == _Oldval)
			*_Dest = _Newval;
		else
			*_Dest = *_First;
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// copy replacing each matching _Oldval, arbitrary iterators
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy replacing each matching _Oldval, random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Replace_copy(_First, _Last,
		_Unchecked(_Dest), _Oldval, _Newval);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		true_type)
	{	// copy replacing each matching _Oldval with _Newval, checked dest
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		false_type)
	{	// copy replacing each matching _Oldval with _Newval, unchecked dest
	return (_Replace_copy(_First, _Last,
		_Dest, _Oldval, _Newval,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *replace_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval, array dest
	return (_Unchecked(
		_STD replace_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Oldval, _Newval)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Replace_copy_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Ty>
struct _Replace_copy_payload
	: _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>,
		_Tiled_range<_FwdIt2> >
	{	// payload for parallel replace_copy
	typedef _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>,
		_Tiled_range<_FwdIt2> > _Mybase;
	typedef _FwdIt2 _Result_type;
	typedef typename _Mybase::_Range_type _Range_type;

	_Replace_copy_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, const _Ty& _Old, const _Ty& _New,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _Exec),
		_Oldval(_Old), _Newval(_New)
		{	// construct with iterator pair, iterator, two values, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		_Replace_copy(_Range._First1, _Range._Last1,
			_Range._First2, _Oldval, _Newval);
		}

	const _Ty& _Oldval;
	const _Ty& _Newval;
	};

		// TEMPLATE FUNCTION _Do_replace_copy_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Ty> inline
	_FwdIt2 _Do_replace_copy_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
	const _Ty& _Oldval, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Replace_copy_payload<_FwdIt1, _FwdIt2, _Ty> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Oldval, _Newval, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Replace_copy_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Ty> inline
	_FwdIt2 _Replace_copy_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
	const _Ty& _Oldval, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	return (_Rechecked(_First2,
		_Do_replace_copy_par(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Oldval, _Newval, _Exec)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy_par(
	_InIt _First, _InIt _Last,
	_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD replace_copy(_First, _Last, _Dest, _Oldval, _Newval));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt replace_copy(_Policy&& _Exec,
		_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	// copy replacing each matching _Oldval with _Newval
	return (_Replace_copy_par(_First, _Last, _Dest, _Oldval, _Newval,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION replace_copy_if
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	for (; _First != _Last; ++_First, (void)++_Dest)
		if (_Pred(*_First))
			*_Dest = _Val;
		else
			*_Dest = *_First;
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// copy replacing each satisfying _Pred, arbitrary iterators
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy replacing each satisfying _Pred, random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Replace_copy_if(_First, _Last,
		_Unchecked(_Dest), _Pred, _Val);
	return (_Ans);
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		true_type)
	{	// copy replacing each satisfying _Pred with _Val, checked dest
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val,
		false_type)
	{	// copy replacing each satisfying _Pred with _Val, unchecked dest
	return (_Replace_copy_if(_First, _Last,
		_Dest, _Pred, _Val,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	_DEBUG_POINTER_IF(_First != _Last, _Pred);
	return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr,
	class _Ty> inline
	_OutTy *replace_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val, array dest
	return (_Unchecked(
		_STD replace_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred, _Val)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Replace_copy_if_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	class _Ty>
struct _Replace_copy_if_payload
	: _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>,
		_Tiled_range<_FwdIt2> >
	{	// payload for parallel replace_copy_if
	typedef _Payload_base_dual_range<
		_Tiled_range<_FwdIt1>,
		_Tiled_range<_FwdIt2> > _Mybase;
	typedef _FwdIt2 _Result_type;
	typedef typename _Mybase::_Range_type _Range_type;

	_Replace_copy_if_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _P, const _Ty& _Val,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First1, _Last1, _First2, _Exec),
		_Pred(_P), _Newval(_Val)
		{	// construct with iterator pair, iterator, predicate, value, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		std::replace_copy_if(_Range._First1, _Range._Last1,
			_Range._First2, _Pred, _Newval);
		}

	_Pr _Pred;
	const _Ty& _Newval;
	};

		// TEMPLATE FUNCTION _Do_replace_copy_if_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	class _Ty> inline
	_FwdIt2 _Do_replace_copy_if_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
	_Pr _Pred, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Replace_copy_if_payload<_FwdIt1, _FwdIt2, _Pr, _Ty> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Pred, _Newval, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Replace_copy_if_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr,
	class _Ty> inline
	_FwdIt2 _Replace_copy_if_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
	_Pr _Pred, const _Ty& _Newval,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	return (_Rechecked(_First2,
		_Do_replace_copy_if_par(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Pred, _Newval, _Exec)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if_par(
	_InIt _First, _InIt _Last,
	_OutIt _Dest, _Pr _Pred, const _Ty& _Newval,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD replace_copy_if(_First, _Last, _Dest, _Pred, _Newval));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt replace_copy_if(_Policy&& _Exec,
		_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	// copy replacing each satisfying _Pred with _Val
	return (_Replace_copy_if_par(_First, _Last, _Dest, _Pred, _Val,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION generate
template<class _FwdIt,
	class _Fn0> inline
	void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	// replace [_First, _Last) with _Func()
	for (; _First != _Last; ++_First)
		*_First = _Func();
	}

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	// replace [_First, _Last) with _Func()
	_DEBUG_RANGE_PTR(_First, _Last, _Func);
	_Generate(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Generate_payload
template<class _FwdIt,
	class _ItOrDiff,
	class _Fn0>
struct _Generate_payload
	: _Payload_base_single_range<_Tiled_range<_FwdIt> >
	{	// payload for parallel generate
	typedef _FwdIt _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base_single_range< _Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Generate_payload(_FwdIt _First, _ItOrDiff _IorD, _Fn0 _F,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _IorD, _Exec), _Func(_F)
		{	// construct with iterator, iterator or size, generator, and policy
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		_Generate(_Range._First, _Range._Last, _Func);
		}

	_Fn0 _Func;
	};

		// TEMPLATE FUNCTION _Do_generate_par
template<class _FwdIt,
	class _ItOrDiff,
	class _Fn0> inline
	_FwdIt _Do_generate_par(
	_FwdIt _First, _ItOrDiff _IorD, _Fn0 _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Generate_payload<_FwdIt, _ItOrDiff, _Fn0> _MyPy;
	_MyPy _Payload(_First, _IorD, _Func, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Generate_par
template<class _FwdIt,
	class _Fn0> inline
	void _Generate_par(
	_FwdIt _First, _FwdIt _Last, _Fn0 _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_Do_generate_par(_First, _Last, _Func, _Exec);
	}

template<class _InIt,
	class _Fn0> inline
	void _Generate_par(
	_InIt _First, _InIt _Last, _Fn0 _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		_STD _Generate(_First, _Last, _Func);
	_CATCH_PAR_END
	}

template<class _Policy,
	class _FwdIt,
	class _Fn0,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void generate(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	// replace [_First, _Last) with _Func()
	_DEBUG_RANGE_PTR(_First, _Last, _Func);
	_Generate_par(_Unchecked(_First), _Unchecked(_Last), _Func,
		_GET_POLICY(_First, _Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION generate_n
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Func();
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_TYPE11(_OutIt) generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_RET11(_Generate_n(_Dest, _Count, _Func));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		_Mutable_iterator_tag)
	{	// replace [_Dest, _Dest + _Count), arbitrary iterators
	return (_Generate_n(_Dest, _Count, _Func));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n1(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		random_access_iterator_tag)
	{	// replace [_Dest, _Dest + _Count), random-access iterators
	_OutIt _Ans = _Dest + _Count;	// also checks range
	_Ans = _Ans;	// to quiet diagnostics
	return (_Rechecked(_Dest,
		_Generate_n(_Unchecked(_Dest), _Count, _Func)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		true_type)
	{	// replace [_Dest, _Dest + _Count) with _Func(), checked dest
	return (_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func,
		false_type)
	{	// replace [_Dest, _Dest + _Count) with _Func(), unchecked dest
	return (_Generate_n1(_Dest, _Count, _Func,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_TYPE11(_OutIt) generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_DEBUG_POINTER_IF(0 < _Count, _Dest);
	_DEBUG_POINTER_IF(0 < _Count, _Func);
	_RET11(_Generate_n(_Dest, _Count, _Func,
		_Is_checked(_Dest)));
	}

template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Fn0> inline
	_TYPE11(_OutTy *) generate_n(_OutTy (&_Dest)[_OutSize], _Diff _Count,
		_Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func(), array dest
	_RET11(_Unchecked(
		_STD generate_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
			_Count, _Func)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Generate_n_par
template<class _RanIt,
	class _Diff,
	class _Fn0> inline
	_RanIt _Generate_n_par(_RanIt _Dest, _Diff _Count, _Fn0 _Func,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Do_generate_par(_Dest, _Count, _Func, _Exec));
	}

template<class _InIt,
	class _Diff,
	class _Fn0> inline
	_InIt _Generate_n_par(
	_InIt _Dest, _Diff _Count, _Fn0 _Func,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD _Generate_n(_Dest, _Count, _Func));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _OutIt,
	class _Diff,
	class _Fn0,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_TYPE11(_OutIt) generate_n(_Policy&& _Exec,
		_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	// replace [_Dest, _Dest + _Count) with _Func()
	_DEBUG_POINTER_IF(0 < _Count, _Dest);
	_DEBUG_POINTER_IF(0 < _Count, _Func);
	_RET11(_Rechecked(_Dest, (_Generate_n_par(_Unchecked(_Dest), _Count, _Func,
				_GET_POLICY(_Dest, _Exec)))));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION unique WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred with previous
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				{	// copy down
				for (; ++_First != _Last; )
					if (!_Pred(*_Firstb, *_First))
						*++_Firstb = _Move(*_First);
				return (++_Firstb);
				}
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred with previous
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Unique(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Unique_payload
template<class _FwdIt,
	class _RanIt,
	class _Pr>
struct _Unique_payload
	: _Payload_base<typename _STD iterator_traits<_RanIt>::difference_type>
	{
	typedef _FwdIt _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base<
		typename _STD iterator_traits<_RanIt>::difference_type> _Mybase;
	typedef typename _STD iterator_traits<_RanIt>::difference_type _Diff;
	typedef _Dual_range<_FwdIt, _RanIt> _Range_type;

	_Unique_payload(_FwdIt _First, _FwdIt _Last, _Diff _Count, _RanIt _Dest,
		_Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_Exec, _Count),
		_Pred(_P),
		_In_tiles(_Mybase::_Ntiles + 1, _FwdIt()),
		_Out_tiles(_Mybase::_Ntiles + 1, _RanIt())
		{
		_Make_tiles(_First, _Last, _Count, _Dest);
		}

	void _Apply(_Range_type _Range)
		{
		*_Range._First2++ = 1;
		_FwdIt _Iter = _Range._First1++;
		while (_Range._First1 != _Range._Last1)
			{
			if (_Pred(*_Iter, *_Range._First1))
				*_Range._First2++ = 0;
			else
				{
				*_Range._First2++ = 1;
				_Iter = _Range._First1;
				}
			++_Range._First1;
			}
		}

	_Range_type _Get_next_tile() const
		{
		int _Index = _Mybase::_Next_index();
		if (_Mybase::_Ntiles <= _Index)
			return (_Make_dual_range(
				_In_tiles[_Mybase::_Ntiles], _In_tiles[_Mybase::_Ntiles],
				_Out_tiles[_Mybase::_Ntiles], _Out_tiles[_Mybase::_Ntiles],
				_Mybase::_Ntiles));
		else
			return (_Make_dual_range(
				_In_tiles[_Index], _In_tiles[_Index + 1],
				_Out_tiles[_Index], _Out_tiles[_Index + 1],
				_Index));
		}

	_Result_type _End() const
		{	// return end of input range iterator
		return (_In_tiles[_Mybase::_Ntiles]);
		}
private:
	void _Make_tiles(_FwdIt _First, _FwdIt _Last, _Diff _Count, _RanIt _Dest)
		{
		_Diff _Sz = _Count / _Mybase::_Ntiles;
		_In_tiles[0] = _First;
		_Out_tiles[0] = _Dest;
		for (int _I = 1; _I < _Mybase::_Ntiles; ++_I)
			{
			_FwdIt _Iter = _In_tiles[_I - 1] == _Last
				? _Last
				: _STD next(_In_tiles[_I - 1], _Sz);
			if (_Iter != _Last)
				_Iter = _STD upper_bound(_Iter, _Last, *_Iter, _Pred);
			_In_tiles[_I] = _Iter;
			_Out_tiles[_I] = _Out_tiles[_I - 1]
				+ _STD distance(_In_tiles[_I - 1], _In_tiles[_I]);
			}
		_In_tiles[_Mybase::_Ntiles] = _Last;
		_Out_tiles[_Mybase::_Ntiles] = _Dest + _Count;
		}
	_Pr _Pred;
	_Dyn_array<_FwdIt> _In_tiles;
	_Dyn_array<_RanIt> _Out_tiles;
	};

		// TEMPLATE FUNCTION _Do_unique_par
template<class _FwdIt,
	class _Pr>
	_FwdIt _Do_unique_par(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt>::value_type _Ty;
	typedef typename _STD iterator_traits<_FwdIt>::difference_type _Diff;
	typedef typename _Dyn_array<_Diff>::iterator _Iter;
	_Diff _Count = _STD distance(_First, _Last);
	_Dyn_array<_Diff> _Copies(_Count, 0);
	typedef _Unique_payload<_FwdIt, _Iter, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Count, _Copies.begin(), _Pred, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	_Do_inclusive_scan_par(_Copies.begin(), _Copies.end(), _Copies.begin(),
		_FUNCTOR(plus, _Iter), 0, _Exec);
	_Dyn_array<_Ty> _Temp(*_STD prev(_Copies.end()), _Ty());
	_Do_pack_par(_Copies.begin(), _Copies.end(),
		_First, _Temp.begin(), _Exec);
	return (_Move_par(_Temp.begin(), _Temp.end(), _First, _Exec));
	}

		// TEMPLATE FUNCTION _Unique_par
template<class _FwdIt,
	class _Pr>
	_FwdIt _Unique_par(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Do_unique_par(_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec)));
	}

template<class _FwdIt,
	class _Pr>
	_FwdIt _Unique_par(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
	execution::sequenced_policy _Exec)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD unique(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt unique(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// remove each satisfying _Pred with previous
	return (_Unique_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION unique
template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	// remove each matching previous
	return (_STD unique(_First, _Last, _FUNCTOR(equal_to, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt unique(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// remove each matching previous
	return (_STD unique(_Exec, _First, _Last, _FUNCTOR(equal_to, _First)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION unique_copy WITH PRED
template<class _InIt,
	class _OutIt,
	class _Ty,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, _Ty *)
	{	// copy compressing pairs satisfying _Pred, input iterators
	_Ty _Val = *_First;

	for (*_Dest++ = _Val; ++_First != _Last; )
		if (!_Pred(_Val, *_First))
			{	// copy unmatched
			_Val = *_First;
			*_Dest++ = _Val;
			}
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag)
	{	// copy compressing pairs satisfying _Pred, input iterators
	return (_Unique_copy(_First, _Last, _Dest, _Pred,
		_Val_type(_First)));
	}

template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr _Pred, forward_iterator_tag)
	{	// copy compressing pairs satisfying _Pred, forward iterators
	_FwdIt _Firstb = _First;

	for (*_Dest++ = *_Firstb; ++_First != _Last; )
		if (!_Pred(*_Firstb, *_First))
			{	// copy unmatched
			_Firstb = _First;
			*_Dest++ = *_Firstb;
			}
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that match
	return (_First == _Last ? _Dest :
		_Unique_copy(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Iter_cat(_First)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// copy compressing pairs that match, checked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// copy compressing pairs that match, unchecked dest
	return (_Unique_copy(_First, _Last,
		_Dest, _Pred, _Iter_cat(_First)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that match
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	_DEBUG_POINTER_IF(_First != _Last, _Pred);
	return (_First == _Last ? _Dest :
		_Unique_copy1(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy compressing pairs that match, array dest
	return (_Unchecked(
		_STD unique_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Do_unique_copy_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_FwdIt2 _Do_unique_copy_par(_FwdIt1 _First, _FwdIt1 _Last,
	_FwdIt2 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::value_type _Ty;
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff;
	typedef typename _Dyn_array<_Diff>::iterator _Iter;
	_Diff _Count = _STD distance(_First, _Last);
	_Dyn_array<_Diff> _Copies(_Count, 0);
	typedef _Unique_payload<_FwdIt1, _Iter, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Count, _Copies.begin(), _Pred, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	_Do_inclusive_scan_par(_Copies.begin(), _Copies.end(), _Copies.begin(),
		_FUNCTOR(plus, _Iter), 0, _Exec);
	return (_Do_pack_par(_Copies.begin(), _Copies.end(),
			_First, _Dest, _Exec));
	}

		// TEMPLATE FUNCTION _Unique_copy_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_FwdIt2 _Unique_copy_par(_FwdIt1 _First, _FwdIt1 _Last,
	_FwdIt2 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	_DEBUG_POINTER_IF(_First != _Last, _Pred);
	return (_Rechecked(_Dest,
		_Do_unique_copy_par(_Unchecked(_First), _Unchecked(_Last),
		_Unchecked(_Dest), _Pred, _Exec)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr>
	_OutIt _Unique_copy_par(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
	execution::sequenced_policy _Exec)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD unique_copy(_First, _Last, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt unique_copy(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	// copy compressing pairs that satisfy _Pred
	return (_Unique_copy_par(_First, _Last, _Dest, _Pred,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION unique_copy
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// copy compressing pairs that match
	return (_STD unique_copy(_First, _Last, _Dest,
		_FUNCTOR(equal_to, _First)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy compressing pairs that match, array dest
	return (_STD unique_copy(_First, _Last, _Dest,
		_FUNCTOR(equal_to, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt unique_copy(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// copy compressing pairs that match
	return (_STD unique_copy(_Exec, _First, _Last, _Dest,
		_FUNCTOR(equal_to, _First)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION reverse_copy
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	for (; _First != _Last; ++_Dest)
		*_Dest = *--_Last;
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// copy reversing elements in [_First, _Last), arbitrary iterators
	return (_Reverse_copy(_First, _Last,
		_Dest));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy reversing elements in [_First, _Last), random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Reverse_copy(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		true_type)
	{	// copy reversing elements in [_First, _Last), checked dest
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		false_type)
	{	// copy reversing elements in [_First, _Last), unchecked dest
	return (_Reverse_copy(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
	return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

template<class _BidIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *reverse_copy(_BidIt _First, _BidIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy reversing elements in [_First, _Last), array dest
	return (_Unchecked(
		_STD reverse_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Advance_and_count
template<class _FwdIt1,
	class _FwdIt2,
	class _Diff,
	class _Cat1,
	class _Cat2>
void _Advance_and_count(
	_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2& _Iter, _Diff& _Count,
	_Cat1, _Cat2)
	{	// set _Count to _Last1 - _First1 and _Iter to _Iter + _Count
	_Count = 0;
	while (_First1 != _Last1)
		{	// next iterator
		++_First1;
		++_Iter;
		++_Count;
		}
	}
template<class _RanIt1,
	class _RanIt2,
	class _Diff>
void _Advance_and_count(
	_RanIt1 _First1, _RanIt1 _Last1, _RanIt2& _Iter, _Diff& _Count,
	random_access_iterator_tag, random_access_iterator_tag)
	{	// set _Count to _Last1 - _First1 and _Iter to _Iter + _Count
	_Count = _Last1 - _First1;
	_Iter += _Count;
	}

		// TEMPLATE FUNCTION _Do_reverse_copy_par
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Do_reverse_copy_par(
	_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typename std::iterator_traits<_BidIt2>::difference_type _Count = 0;
	_BidIt2 _Last2 = _First2;
	_Advance_and_count(_First1, _Last1, _Last2, _Count,
		_Iter_cat(_First1), _Iter_cat(_First2));
	typedef _Copy_payload<_BidIt1, std::reverse_iterator<_BidIt2> > _MyPy;
	_MyPy _Payload(_First1, _Last1, std::make_reverse_iterator(_Last2), _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Last2);
	}

		// TEMPLATE FUNCTION _Reverse_copy_par
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Reverse_copy_par(
	_BidIt1 _First1, _BidIt1 _Last1, _BidIt2 _First2,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	return (_Rechecked(_First2,
		_Do_reverse_copy_par(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Exec)));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy_par(
	_BidIt _First, _BidIt _Last, _OutIt _Dest,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD reverse_copy(_First, _Last, _Dest));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _BidIt,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt reverse_copy(_Policy&& _Exec,
		_BidIt _First, _BidIt _Last, _OutIt _Dest)
	{	// copy reversing elements in [_First, _Last)
	return (_Reverse_copy_par(_First, _Last, _Dest,
		_GET_POLICY_BIDIR2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION rotate_copy
template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	// copy rotating [_First, _Last)
	_Dest = _STD copy(_Mid, _Last, _Dest);
	return (_STD copy(_First, _Mid, _Dest));
	}

 #if _HAS_CPP17
template<class _FwdIt1,
	class _FwdIt2>
	_FwdIt2 _Rotate_copy_par(
	_FwdIt1 _First, _FwdIt1 _Mid, _FwdIt1 _Last, _FwdIt2 _Dest,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First, _Mid, _Dest);
	_DEBUG_RANGE_PTR(_Mid, _Last, _Dest);
	_Dest = (_Rechecked(_Dest,
		_Do_copy_par(_Unchecked(_Mid), _Unchecked(_Last),
		_Unchecked(_Dest), _Exec)));
	return (_Rechecked(_Dest,
		_Do_copy_par(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Dest), _Exec)));
	}

template<class _FwdIt,
	class _OutIt>
	_OutIt _Rotate_copy_par(
	_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest,
	execution::sequenced_policy)
	{	// perform function in parallel
	_TRY_BEGIN
		return (_STD rotate_copy(_First, _Mid, _Last, _Dest));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt rotate_copy(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest)
	{	// copy rotating [_First, _Last)
	return (_Rotate_copy_par(_First, _Mid, _Last, _Dest,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION shuffle WITH URNG
template<class _RanIt,
	class _Fn1,
	class _Diff> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
	{	// shuffle nonempty [_First, _Last) using random function _Func
	_RanIt _Next = _First;
	for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
		{	// randomly swap element with self or earlier element
		_Diff _Off = _Func(_Index);

 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Off < 0 || _Index <= _Off)
			{	// report error
			_DEBUG_ERROR("random value out of range");
			_SCL_SECURE_OUT_OF_RANGE;
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
		_SCL_SECURE_VALIDATE_RANGE(0 <= _Off && _Off < _Index);
 #endif /* _ITERATOR_DEBUG_LEVEL */

		if (_Next != (_First + _Off))
			_STD iter_swap(_Next, _First + _Off);
		}
	}

template<class _RanIt,
	class _Fn1> inline
	void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	// shuffle [_First, _Last) using random function _Func
	_DEBUG_RANGE(_First, _Last);
	if (2 <= _Last - _First)
		{	// validate _Func and shuffle
		_DEBUG_POINTER(_Func);
		_Random_shuffle(_Unchecked(_First), _Unchecked(_Last), _Func,
			_Dist_type(_First));
		}
	}

template<class _RanIt,
	class _Urng> inline
	void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
	{	// shuffle [_First, _Last) using URNG _Func
	typedef typename iterator_traits<_RanIt>::difference_type _Diff;
	typedef typename remove_reference<_Urng>::type _Urng0;
	_Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
	_Random_shuffle(_First, _Last, _Rng);
	}

		// TEMPLATE FUNCTION random_shuffle WITH RANDOM FN
template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
	{	// shuffle [_First, _Last) using random function _Func
	_Random_shuffle(_First, _Last, _Func);
	}

	// STRUCT _Rand_urng_from_func
struct _Rand_urng_from_func
	{	// wrap rand() as a URNG
	typedef unsigned int result_type;

	static result_type (min)()
		{	// return minimum possible generated value
		return (0);
		}

	static result_type (max)()
		{	// return maximum possible generated value
		return (RAND_MAX);
		}

	result_type operator()()
		{	// invoke rand()
		return (_CSTD rand());
		}
	};

		// TEMPLATE FUNCTION random_shuffle
template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	// shuffle [_First, _Last) using rand() -- RETAINED
	_Rand_urng_from_func _Func;
	_STD shuffle(_First, _Last, _Func);
	}

		// TEMPLATE FUNCTION partition
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		forward_iterator_tag)
	{	// move elements satisfying _Pred to front, forward iterators
	while (_First != _Last && _Pred(*_First))
		++_First;	// skip in-place elements at beginning

	if (_First == _Last)
		return (_First);	// done

	for (_FwdIt _Next = _STD next(_First); _Next != _Last; ++_Next)
		if (_Pred(*_Next))
			_STD iter_swap(_First++, _Next);	// out of place, swap and loop

	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		bidirectional_iterator_tag)
	{	// move elements satisfying _Pred to front, bidirectional iterators
	for (; ; ++_First)
		{	// find any out-of-order pair
		for (; _First != _Last && _Pred(*_First); ++_First)
			;	// skip in-place elements at beginning
		if (_First == _Last)
			break;	// done

		for (; _First != --_Last && !_Pred(*_Last); )
			;	// skip in-place elements at end
		if (_First == _Last)
			break;	// done

		_STD iter_swap(_First, _Last);	// out of place, swap and loop
		}
	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// move elements satisfying _Pred to beginning of sequence
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Rechecked(_First,
		_Partition(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Iter_cat(_First))));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt partition(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// move elements satisfying _Pred to beginning of sequence
	return (_STD partition(_First, _Last, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION stable_partition
template<class _BidIt,
	class _Diff,
	class _Ty> inline
	_BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
	{	// rotate [_First, _Last) using temp buffer
	if (_Count1 == 0 || _Count2 == 0)
		{	// do nothing
		_STD advance(_First, _Count2);
		return (_First);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	// buffer left partition, then copy parts
		_Move(_First, _Mid, _Tempbuf._Init());
		_Move(_Mid, _Last, _First);
		return (_Move_backward(_Tempbuf._First(), _Tempbuf._Last(),
			_Last));
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	// buffer right partition, then copy parts
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Move_backward(_First, _Mid, _Last);
		return (_Move(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
	else
		{	// buffer too small, rotate in place
		return (_STD rotate(_First, _Mid, _Last));
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
	{	// partition preserving order of equivalents, using _Pred
	if (_Count == 0)
		return (_First);
	else if (_Count == 1)
		return (_Pred(*_First) ? _Last : _First);
	else if (_Count <= _Tempbuf._Maxlen())
		{	// temp buffer big enough, copy right partition out and back
		_BidIt _Next = _First;
		for (_Tempbuf._Init(); _First != _Last; ++_First)
			if (_Pred(*_First))
				*_Next++ = _Move(*_First);
			else
				*_Tempbuf++ = _Move(*_First);

		_Move(_Tempbuf._First(), _Tempbuf._Last(), _Next);	// copy back
		return (_Next);
		}
	else
		{	// temp buffer not big enough, divide and conquer
		_BidIt _Mid = _First;
		_STD advance(_Mid, _Count / 2);

		_BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
			_Count / 2, _Tempbuf);	// form L1R1 in left half
		_BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
			_Count - _Count / 2, _Tempbuf);	// form L2R2 in right half

		_Diff _Count1 = 0;
		_Distance(_Left, _Mid, _Count1);
		_Diff _Count2 = 0;
		_Distance(_Mid, _Right, _Count2);

		return (_Buffered_rotate(_Left, _Mid, _Right,
			_Count1, _Count2, _Tempbuf));	// rotate L1R1L2R2 to L1L2R1R2
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	// partition preserving order of equivalents, using _Pred
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf(_Count);
	return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// partition preserving order of equivalents, using _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_First == _Last ? _First
		: _Rechecked(_First,
			_Stable_partition(_Unchecked(_First), _Unchecked(_Last),
				_Pred, _Dist_type(_First), _Val_type(_First))));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _BidIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_BidIt stable_partition(_Policy&& _Exec,
		_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// partition preserving order of equivalents, using _Pred
	return (_STD stable_partition(_First, _Last, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION binary_search WITH PRED
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	// test if _Val equivalent to some element, using _Pred
	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

		// TEMPLATE FUNCTION binary_search
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// test if _Val equivalent to some element, using operator<
	return (_STD binary_search(_First, _Last, _Val, _FUNCTOR(less, _First)));
	}

		// TEMPLATE FUNCTION merge WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	// merge either first or second
			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
				{	// merge first
				*_Dest++ = *_First2++;
				if (_First2 == _Last2)
					break;
				}
			else
				{	// merge second
				*_Dest++ = *_First1++;
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
	return (_Copy_impl(_First2, _Last2, _Dest));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
		input_iterator_tag, _Mutable_iterator_tag)
	{	// copy merging ranges, both using _Pred, arbitrary iterators
	return (_Merge0(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
		random_access_iterator_tag, random_access_iterator_tag)
	{	// copy merging ranges, both using _Pred, random-access iterators
	_OutIt _Ans = _Dest + (_Last1 - _First1)
		+ (_Last2 - _First2);	// also checks range
	_Merge0(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred);
	return (_Ans);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// copy merging ranges, both using _Pred, checked dest
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// copy merging ranges, both using _Pred, unchecked dest
	return (_Merge2(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred, _Iter_cat(_First1),
		_Iter_cat(_First2), _Iter_cat(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER_IF(_First1 != _Last1 || _First2 != _Last2, _Dest);
	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy merging ranges, both using _Pred, array dest
	return (_Unchecked(
		_STD merge(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Bounded_distance
template
	<class _FwdIt,
	class _Diff,
	class _Cat>
	_Diff _Bounded_distance(_FwdIt _First, _FwdIt _Last, _Diff _Bound,
	_Cat)
		{	// count steps from _First to _Last without exceeding _Bound
		_Diff _Res = 0;
		while (_First != _Last && _Res != _Bound)
			{	// advance _First
			++_First;
			++_Res;
			}
		return (_Res);
		}

template<class _RanIt,
	class _Diff>
	_Diff _Bounded_distance(_RanIt _First, _RanIt _Last, _Diff _Bound,
	random_access_iterator_tag)
		{	// count steps from _First to _Last without exceeding _Bound
		return (_Last - _First < _Bound ? _Last - _First : _Bound);
		}

template<class _FwdIt,
	class _Diff>
	_Diff _Bounded_distance(_FwdIt _First, _FwdIt _Last, _Diff _Bound)
	{	// count steps from _First to _Last without exceeding _Bound
	return (_Bounded_distance(_First, _Last, _Bound, _Iter_cat(_First)));
	}

		// TEMPLATE FUNCTION _Bounded_next
template<class _FwdIt,
	class _Diff,
	class _Cat>
	_FwdIt _Bounded_next(_FwdIt _First, _FwdIt _Last,
	_Diff _Bound, _Cat)
		{	// return _First + _Bound but not past _Last
		_Diff _Res = 0;
		while (_First != _Last && _Res != _Bound)
			{	// advance _First
			++_First;
			++_Res;
			}
		return (_First);
		}

template<class _RanIt, class _Diff>
	_RanIt _Bounded_next(_RanIt _First, _RanIt _Last, _Diff _Bound,
	random_access_iterator_tag)
		{	// return _First + _Bound but not past _Last
		return (_Bound <= _Last - _First? _First + _Bound : _First);
		}

template<class _FwdIt,
	class _Diff>
	_FwdIt _Bounded_next(_FwdIt _First, _FwdIt _Last, _Diff _Bound)
	{
	return (_Bounded_next(_First, _Last, _Bound, _Iter_cat(_First)));
	}

		// TEMPLATE CLASS _Merge_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
struct _Merge_payload
	: public _Payload_base<typename std::iterator_traits<_FwdIt1>
		::difference_type>
	{	// payload for parallel merge
	typedef _Payload_base<typename std::iterator_traits<_FwdIt1>
		::difference_type> _Mybase;
	typedef _FwdIt1 _Iter1;
	typedef _FwdIt2 _Iter2;
	typedef _FwdIt3 _Iter3;
	typedef _Iter3 _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Triple_range<_FwdIt1, _FwdIt2, _FwdIt3> _Range_type;
	typedef typename std::iterator_traits<_FwdIt1>::difference_type _Diff;

	_Merge_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
		_Pr _P,
		execution::_Parallel_policy& _Exec)
			: _Mybase(_Exec, 0),
			_In1_tiles(new _FwdIt1[_Mybase::_Ntiles + 1]),
			_In2_tiles(new _FwdIt2[_Mybase::_Ntiles + 1]),
			_Out_tiles(new _FwdIt3[_Mybase::_Ntiles + 1]),
			_Pred(_P)
		{	// construct with two iterator pairs, iterator, predicate, and policy
		_Make_tiles(_First1, _Last1, _First2, _Last2, _Dest);
		}

	~_Merge_payload() _NOEXCEPT
		{
		delete [] _Out_tiles;
		delete [] _In2_tiles;
		delete [] _In1_tiles;
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		std::merge(_Range._First1, _Range._Last1, _Range._First2, _Range._Last2,
			_Range._First3, _Pred);
		}

	_Range_type _Get_next_tile() const
		{	// return next tile
		int _Index = _Mybase::_Next_index();
		if (_Mybase::_Ntiles <= _Index)
			return (_Make_triple_range(
				_In1_tiles[_Mybase::_Ntiles], _In1_tiles[_Mybase::_Ntiles],
				_In2_tiles[_Mybase::_Ntiles], _In2_tiles[_Mybase::_Ntiles],
				_Out_tiles[_Mybase::_Ntiles], _Out_tiles[_Mybase::_Ntiles],
				_Index
				));
		else
			return (_Make_triple_range(
				_In1_tiles[_Index], _In1_tiles[_Index + 1],
				_In2_tiles[_Index], _In2_tiles[_Index + 1],
				_Out_tiles[_Index], _Out_tiles[_Index + 1],
				_Index
				));
		}
	_FwdIt1 _End() const
		{	// return end of output iterator
		return _Out_tiles[_Mybase::_Ntiles];
		}
private:
	void _Make_tiles(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest)
		{	// create iterator ranges
		_In1_tiles[0] = _First1;
		_In2_tiles[0] = _First2;
		_Out_tiles[0] = _Dest;
		_Diff _Block_size =
			std::distance(_First1, _Last1) / _Mybase::_Ntiles;
		int _I = 1;
		for ( ; _I < _Mybase::_Ntiles
				&& _In1_tiles[_I - 1] != _Last1
				&& _In2_tiles[_I - 1] != _Last2;
				++_I)
			{	// create a tile
			_Diff _Count =
				_Bounded_distance(_In1_tiles[_I - 1], _Last1, _Block_size);
			_Count = _Count < _Block_size ? _Count : _Block_size;
			_FwdIt1 _Pivot = std::next(_In1_tiles[_I - 1], _Count - 1);
			_In1_tiles[_I] =
				std::upper_bound(_Pivot, _Last1, *_Pivot, _Pred);
			_In2_tiles[_I] = std::lower_bound(
				_In2_tiles[_I - 1], _Last2, *_Pivot, _Pred);
			_FwdIt3 _Iter3 = _Out_tiles[_I - 1];
			std::advance(_Iter3,
				std::distance(_In1_tiles[_I - 1], _In1_tiles[_I]));
			std::advance(_Iter3,
				std::distance(_In2_tiles[_I - 1], _In2_tiles[_I]));
			_Out_tiles[_I] = _Iter3;
			}
		_FwdIt3 _Last3 = _Out_tiles[_I - 1];
		std::advance(_Last3, std::distance(_In1_tiles[_I - 1], _Last1));
		std::advance(_Last3, std::distance(_In2_tiles[_I - 1], _Last2));
		for ( ; _I < _Mybase::_Ntiles + 1; ++_I)
			{	// fill in the rest of the iterators
			_In1_tiles[_I] = _Last1;
			_In2_tiles[_I] = _Last2;
			_Out_tiles[_I] = _Last3;
			}
		}
	_FwdIt1 *_In1_tiles;
	_FwdIt2 *_In2_tiles;
	_FwdIt3 *_Out_tiles;
	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_merge_par
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr> inline
	_FwdIt3 _Do_merge_par(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _First3, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Merge_payload<_FwdIt1, _FwdIt2, _FwdIt3, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _First2, _Last2, _First3, _Pred, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Merge_par
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr> inline
	_FwdIt3 _Merge_par(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER_IF(_First1 != _Last1 || _First2 != _Last2, _Dest);
	return (_Rechecked(_Dest,
		_Do_merge_par(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2),
			_Unchecked(_Dest),
			_Pred, _Exec)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge_par(
	_InIt1 _First1, _InIt1 _Last1,
	_InIt2 _First2, _InIt2 _Last2,
	_OutIt _Dest, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

		// TEMPLATE FUNCTION PARALLEL merge WITH PRED
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt merge(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// copy merging ranges, both using _Pred
	return (_Merge_par(_First1, _Last1,
				_First2, _Last2, _Dest, _Pred,
				_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION merge
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// copy merging ranges, both using operator<
	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// copy merging ranges, both using operator<, array dest
	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt merge(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// copy merging ranges, both using operator<
	return (_STD merge(_Exec, _First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION inplace_merge WITH PRED
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr> inline
	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred,
		bool _In_place = false)
	{	// merge backwards to _Dest, using _Pred
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	// merge either first or second
			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
				{	// merge first
				*--_Dest = _Move(*_Last1);
				++_Last2;
				if (_First1 == _Last1)
					break;
				}
			else
				{	// merge second
				*--_Dest = _Move(*_Last2);
				++_Last1;
				if (_First2 == _Last2)
					break;
				}
			}

	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
	if (!_In_place)
		_Dest = _Move_backward(_First1, _Last1, _Dest);
	return (_Dest);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, bool _In_place = false)
	{	// move merging ranges, both using _Pred
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	// merge either first or second
			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
				{	// merge first
				*_Dest++ = _Move(*_First2++);
				if (_First2 == _Last2)
					break;
				}
			else
				{	// merge second
				*_Dest++ = _Move(*_First1++);
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
	if (!_In_place)
		_Dest = _Move(_First2, _Last2, _Dest);
	return (_Dest);
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	if (_Count1 == 0 || _Count2 == 0)
		;	// do nothing
	else if (_Count1 + _Count2 == 2)
		{	// order two one-element partitions
		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
			_STD iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	// buffer left partition, then merge
		_Move(_First, _Mid, _Tempbuf._Init());
		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
			_Mid, _Last, _First, _Pred, true);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	// buffer right partition, then merge
		_Move(_Mid, _Last, _Tempbuf._Init());
		_Merge_backward(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred, true);
		}
	else
		{	// buffer too small, divide and conquer
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
			{	// left larger, cut it in half and partition right to match
			_Count1n = _Count1 / 2, _Count2n = 0;
			_Firstn = _First;
			_STD advance(_Firstn, _Count1n);
			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
			_Distance(_Mid, _Lastn, _Count2n);
			}
		else
			{	// right larger, cut it in half and partition left to match
			_Count1n = 0, _Count2n = _Count2 / 2;
			_Lastn = _Mid;
			_STD advance(_Lastn, _Count2n);
			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
			_Distance(_First, _Firstn, _Count1n);
			}
		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
		_Buffered_merge(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
		_Buffered_merge(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
		_Diff *, _Ty *)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	_Diff _Count1 = 0;
	_Distance(_First, _Mid, _Count1);
	_Diff _Count2 = 0;
	_Distance(_Mid, _Last, _Count2);
	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
	_Buffered_merge(_First, _Mid, _Last,
		_Count1, _Count2, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
	if (_First != _Mid && _Mid != _Last)
		_Inplace_merge(
			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
			_Dist_type(_First), _Val_type(_First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _BidIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void inplace_merge(_Policy&&,
		_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
	_STD inplace_merge(_First, _Mid, _Last, _Pred);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION inplace_merge
template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
	_STD inplace_merge(_First, _Mid, _Last, _FUNCTOR(less, _First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _BidIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void inplace_merge(_Policy&&,
		_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
	_STD inplace_merge(_First, _Mid, _Last);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION sort WITH PRED
template<class _BidIt,
	class _Pr,
	class _Ty> inline
	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
	{	// insertion sort [_First, _Last), using _Pred
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	// order next element
			_BidIt _Next1 = _Next;
			_Ty _Val = _Move(*_Next);

			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
				{	// found new earliest element, move to front
				_Move_backward(_First, _Next, ++_Next1);
				*_First = _Move(_Val);
				}
			else
				{	// look for insertion point after first
				for (_BidIt _First1 = _Next1;
					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
					_Next1 = _First1)
					*_Next1 = _Move(*_First1);	// move hole down
				*_Next1 = _Move(_Val);	// insert element in hole
				}
			}
	}

template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// insertion sort [_First, _Last), using _Pred
	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median of three elements to middle
	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
		_STD iter_swap(_Mid, _First);
	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))
		{	// swap middle and last, then test first again
		_STD iter_swap(_Last, _Mid);
		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
			_STD iter_swap(_Mid, _First);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// sort median element to middle
	if (40 < _Last - _First)
		{	// median of nine
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3(_First, _Mid, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt>
		_Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// partition [_First, _Last), using _Pred
	_RanIt _Mid = _First + (_Last - _First) / 2;
	_Median(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_DEBUG_LT_PRED(_Pred, *(_Pfirst - 1), *_Pfirst)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst)
		&& !_Pred(*_Pfirst, *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	// partition
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))
				;
			else if (_Pred(*_Gfirst, *_Pfirst))
				break;
			else if (_Plast++ != _Gfirst)
				_STD iter_swap(_Plast - 1, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))
				;
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				break;
			else if (--_Pfirst != _Glast - 1)
				_STD iter_swap(_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	// no room at bottom, rotate pivot upward
			if (_Plast != _Gfirst)
				_STD iter_swap(_Pfirst, _Plast);
			++_Plast;
			_STD iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	// no room at top, rotate pivot downward
			if (--_Glast != --_Pfirst)
				_STD iter_swap(_Glast, _Pfirst);
			_STD iter_swap(_Pfirst, --_Plast);
			}
		else
			_STD iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff,
	class _Pr> inline
	void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_Diff _Count;
	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
		{	// divide and conquer by quicksort
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);
		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

		if (_Mid.first - _First < _Last - _Mid.second)
			{	// loop on second half
			_Sort(_First, _Mid.first, _Ideal, _Pred);
			_First = _Mid.second;
			}
		else
			{	// loop on first half
			_Sort(_Mid.second, _Last, _Ideal, _Pred);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	// heap sort if too many divisions
		_STD make_heap(_First, _Last, _Pred);
		_STD sort_heap(_First, _Last, _Pred);
		}
	else if (2 <= _Count)
		_Insertion_sort(_First, _Last, _Pred);	// small
	}

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(2 <= _Last - _First, _Pred);
	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void sort(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last), using _Pred
	_STD sort(_First, _Last, _Pred);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION sort
template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	// order [_First, _Last), using operator<
	_STD sort(_First, _Last, _FUNCTOR(less, _First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void sort(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last)
	{	// order [_First, _Last), using operator<
	_STD sort(_First, _Last);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION stable_sort WITH PRED
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr> inline
	void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr _Pred)
	{	// copy merging chunks, using _Pred
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	// copy merging pairs of adjacent chunks
		_BidIt _Mid1 = _First;
		_STD advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		_STD advance(_Mid2, _Chunk);

		_Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		_Move(_First, _Last, _Dest);	// copy partial last chunk
	else
		{	// copy merging whole and partial last chunk
		_BidIt _Mid1 = _First;
		_STD advance(_Mid1, _Chunk);

		_Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	// sort using temp buffer for merges, using _Pred
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	// sort chunks
		_BidIt _Midn = _Mid;
		_STD advance(_Midn, (int)_ISORT_MAX);

		_Insertion_sort(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	// merge adjacent pairs of chunks to and from temp buffer
		_Chunked_merge(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count, _Pred);
		_Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	if (_Count <= _ISORT_MAX)
		_Insertion_sort(_First, _Last, _Pred);	// small
	else
		{	// sort halves and merge
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		_STD advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	// temp buffer big enough, sort each half using buffer
			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
				_Tempbuf, _Pred);
			}
		else
			{	// temp buffer not big enough, divide and conquer
			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
			}

		_Buffered_merge(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_Diff _Count = 0;
	_Distance(_First, _Last, _Count);
	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_DEBUG_RANGE(_First, _Last);
	if (_First != _Last)
		{	// validate predicate and sort
		_DEBUG_POINTER_IF(_STD next(_First) != _Last, _Pred);
		_Stable_sort(_Unchecked(_First), _Unchecked(_Last),
			_Dist_type(_First), _Val_type(_First), _Pred);
		}
	}

 #if _HAS_CPP17
template<class _Policy,
	class _BidIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void stable_sort(_Policy&& _Exec,
		_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// sort preserving order of equivalents, using _Pred
	_STD stable_sort(_First, _Last, _Pred);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION stable_sort
template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	// sort preserving order of equivalents, using operator<
	_STD stable_sort(_First, _Last, _FUNCTOR(less, _First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _BidIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void stable_sort(_Policy&& _Exec,
		_BidIt _First, _BidIt _Last)
	{	// sort preserving order of equivalents, using operator<
	_STD stable_sort(_First, _Last);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION partial_sort WITH PRED
template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr _Pred, _Ty *)
	{	// order [_First, _Last) up to _Mid, using _Pred
	_STD make_heap(_First, _Mid, _Pred);

	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
			{	// replace top with new largest
			_Ty _Val = _Move(*_Next);
			_Pop_heap(_First, _Mid, _Next, _Move(_Val), _Pred,
				_Dist_type(_First));
			}
	_STD sort_heap(_First, _Mid, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last) up to _Mid, using _Pred
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	_DEBUG_POINTER_IF(2 <= _Last - _First, _Pred);
	_Partial_sort(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
		_Val_type(_First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void partial_sort(_Policy&&,
		_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	// order [_First, _Last) up to _Mid, using _Pred
	return (partial_sort(_First, _Mid, _Last, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION partial_sort
template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// order [_First, _Last) up to _Mid, using operator<
	_STD partial_sort(_First, _Mid, _Last, _FUNCTOR(less, _First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void partial_sort(_Policy&&,
		_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	// order [_First, _Last) up to _Mid
	return (partial_sort(_First, _Mid, _Last));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION partial_sort_copy WITH PRED
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
	{	// copy [_First1, _Last1) into [_First2, _Last2) using _Pred
	_RanIt _Mid2 = _First2;
	for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, (void)++_Mid2)
		*_Mid2 = *_First1;	// copy min(_Last1 - _First1, _Last2 - _First2)
	_STD make_heap(_First2, _Mid2, _Pred);

	for (; _First1 != _Last1; ++_First1)
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			_Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
				_Ty(*_First1), _Pred);	// replace top with new largest

	_STD sort_heap(_First2, _Mid2, _Pred);
	return (_Mid2);
	}

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	// copy [_First1, _Last1) into [_First2, _Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
//	_DEBUG_POINTER(_Pred);	// checked in make_heap
	return (_First1 == _Last1 || _First2 == _Last2 ? _First2
		: _Rechecked(_First2,
			_Partial_sort_copy(
				_Unchecked(_First1), _Unchecked(_Last1),
				_Unchecked(_First2), _Unchecked(_Last2), _Pred,
				_Dist_type(_First2), _Val_type(_First1))));
	}

		// TEMPLATE FUNCTION partial_sort_copy
template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	// copy [_First1, _Last1) into [_First2, _Last2), using operator<
	return (_STD partial_sort_copy(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(less, _First1)));
	}

		// TEMPLATE FUNCTION nth_element WITH PRED
template<class _RanIt,
	class _Pr> inline
	void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	// order Nth element, using _Pred
	if (_Nth == _Last)
		return;	// nothing to do

	for (; _ISORT_MAX < _Last - _First; )
		{	// divide and conquer, ordering partition containing Nth
		pair<_RanIt, _RanIt> _Mid =
			_Unguarded_partition(_First, _Last, _Pred);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	// Nth inside fat pivot, done
		else
			_Last = _Mid.first;
		}

	_Insertion_sort(_First, _Last, _Pred);	// sort any remainder
	}

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	// order Nth element, using _Pred
	_DEBUG_RANGE(_First, _Nth);
	_DEBUG_RANGE(_Nth, _Last);
	_DEBUG_POINTER_IF(2 <= _Last - _First, _Pred);
	_Nth_element(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void nth_element(_Policy&& _Exec,
		_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	// order Nth element, using _Pred
	_STD nth_element(_First, _Nth, _Last, _Pred);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION nth_element
template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	// order Nth element, using operator<
	_STD nth_element(_First, _Nth, _Last, _FUNCTOR(less, _First));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	void nth_element(_Policy&& _Exec,
		_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	// order Nth element, using operator<
	_STD nth_element(_First, _Nth, _Last);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION includes WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// test if set [_First1, _Last1) in [_First2, _Last2), using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
			return (false);
		else if (_Pred(*_First1, *_First2))
			++_First1;
		else
			{	// advance both
			++_First1;
			++_First2;
			}
	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// test if set [_First1, _Last1) in [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool includes(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// test if set [_First1, _Last1) in [_First2, _Last2), using _Pred
	return (_STD includes(_First1, _Last1, _First2, _Last2, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION includes
template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// test if all [_First1, _Last1) in [_First2, _Last2), using operator<
	return (_STD includes(_First1, _Last1, _First2, _Last2,
		_FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool includes(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// test if set [_First1, _Last1) in [_First2, _Last2), using operator<
	return (_STD includes(_First1, _Last1, _First2, _Last2));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_union WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			{	// copy first
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	// copy second
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	// advance both
			*_Dest++ = *_First1;
			++_First1;
			++_First2;
			}
	_Dest = _STD copy(_First1, _Last1, _Dest);
	return (_STD copy(_First2, _Last2, _Dest));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_union(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	_DEBUG_POINTER_IF(_First1 != _Last1 || _First2 != _Last2, _Dest);
	return (_Set_union2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_union(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Set_dual_selection_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
struct _Set_dual_selection_payload
	: _Payload_base<_STD size_t>
	{	// payload for parallel set_union and set_symmetric_difference
	enum _Action { _Copy_first, _Copy_first_skip, _Copy_second, _Skip, _Skip_all };
	enum { _Scan, _Rescan, _Done } _State;
	typedef _FwdIt3 _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base<size_t> _Mybase;
	typedef typename _STD iterator_traits<_FwdIt3>::difference_type _Diff;
	typedef _Quadruple_range<_FwdIt1, _FwdIt2, _Action*, _FwdIt3> _Range_type;

	_Set_dual_selection_payload(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2,
		_FwdIt3 _First3,
		_Pr _P,
		execution::_Parallel_policy& _Exec,
		bool _Union = false)
		: _Mybase(_Exec, _STD distance(_First1, _Last1)),
		_In1_tiles(_Mybase::_Ntiles + 1, _First1),
		_In2_tiles(_Mybase::_Ntiles + 1, _First2),
		_Copy_counts(_Mybase::_Ntiles + 1, 0),
		_Actions(_STD distance(_First1, _Last1) + _STD distance(_First2, _Last2), _Skip_all),
		_Action_tiles(_Mybase::_Ntiles + 1, nullptr),
		_Out_tiles(_Mybase::_Ntiles + 1, _First3),
		_Pred(_P),
		_Alg_union(_Union),
		_State(_Scan)
		{	// construct from three ranges and predicate
		_Make_tiles(_First1, _Last1, _First2, _Last2);
		_Out_tiles[0] = _First3;
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		switch(_State)
			{
			case _Scan: _Do_scan(_Range); break;
			case _Rescan: _Do_rescan(_Range); break;
			case _Done: break;
			}
		}

	bool _Prepare_next_pass()
		{	// return true if there is another pass to be run
		switch(_State)
			{	// prepare next pass
			case _Scan: _Retile(); _State = _Rescan; break;
			case _Rescan: _State = _Done; break;
			case _Done: break;
			}
		return (_State != _Done);
		}

	_Range_type _Get_next_tile() const
		{	// return next tile
		int _Index = _Mybase::_Next_index();
		if (_Mybase::_Ntiles <= _Index)
			return (_Make_quadruple_range(
				_In1_tiles[_Mybase::_Ntiles], _In1_tiles[_Mybase::_Ntiles],
				_In2_tiles[_Mybase::_Ntiles], _In2_tiles[_Mybase::_Ntiles],
				_Action_tiles[_Mybase::_Ntiles], _Action_tiles[_Mybase::_Ntiles],
				_Out_tiles[_Mybase::_Ntiles], _Out_tiles[_Mybase::_Ntiles],
				_Mybase::_Ntiles));
		else
			return (_Make_quadruple_range(
				_In1_tiles[_Index], _In1_tiles[_Index + 1],
				_In2_tiles[_Index], _In2_tiles[_Index + 1],
				_Action_tiles[_Index], _Action_tiles[_Index + 1],
				_Out_tiles[_Index], _Out_tiles[_Index + 1],
				_Index));
		}

	_Result_type _End() const
		{	// return end of output range iterator
		return (_Out_tiles[_Mybase::_Ntiles]);
		}
private:
	_Dyn_array<_FwdIt1> _In1_tiles;
	_Dyn_array<_FwdIt2> _In2_tiles;
	_Dyn_array<_Diff> _Copy_counts;
	_Dyn_array<_Action> _Actions;
	_Dyn_array<_Action*> _Action_tiles;
	_Dyn_array<_FwdIt3> _Out_tiles;
	_Pr _Pred;
	bool _Alg_union;

	void _Do_scan(_Range_type _Range)
		{	// determine output from input ranges
		_Diff _Ncopies = 0;
		while (_Range._First1 != _Range._Last1 && _Range._First2 != _Range._Last2)
			{	// check a pair of input values
			if (_Pred(*_Range._First1, *_Range._First2))
				{	// *_First1 < *_First2, copy *_First1
				*_Range._First3++ = _Copy_first;
				++_Range._First1;
				++_Ncopies;
				}
			else if (_Pred(*_Range._First2, *_Range._First1))
				{	// *_First2 < *_First1, copy *_FIrst2
				*_Range._First3++ = _Copy_second;
				++_Range._First2;
				++_Ncopies;
				}
			else if (_Alg_union)
				{	// *_First1 == *_First2; for set_union, copy *_First1
				*_Range._First3++ = _Copy_first_skip;
				++_Range._First1;
				++_Range._First2;
				++_Ncopies;
				}
			else
				{	// *_First1 == *_First2; for set_symmetric_difference, skip
				*_Range._First3++ = _Skip;
				++_Range._First1;
				++_Range._First2;
				}
			}
		while (_Range._First1 != _Range._Last1)
			{	// copy remainger of first input range
			*_Range._First3++ = _Copy_first;
			++_Range._First1;
			++_Ncopies;
			}
		while (_Range._First2 != _Range._Last2)
			{	// copy remainder of second input range
			*_Range._First3++ = _Copy_second;
			++_Range._First2;
			++_Ncopies;
			}
		_Copy_counts[_Range._Index] = _Ncopies;
		}

	void _Do_rescan(_Range_type _Range)
		{	// second pass: copy values found in first pass
		while (_Range._First3 != _Range._Last3)
			{	// loop through results of first pass
			switch(*_Range._First3++)
				{	// copy or skip value
				case _Copy_first_skip: ++_Range._First2; // fall through
				case _Copy_first: *_Range._First4++ = *_Range._First1++; break;
				case _Copy_second: *_Range._First4++ = *_Range._First2++; break;
				case _Skip: ++_Range._First1; ++_Range._First2; break;
				case _Skip_all: _Range._First3 = _Range._Last3; break;
				}
			}
		}

	void _Retile()
		{	// compute output tile limits
		for (int _I = 1; _I <= _Mybase::_Ntiles; ++_I)
			_Out_tiles[_I] = _STD next(_Out_tiles[_I - 1], _Copy_counts[_I - 1]);
		}

	void _Make_tiles(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
		{	// compute initial tile bounds
		_Diff _Sz = _Mybase::_Count / _Mybase::_Ntiles;
		_In1_tiles[0] = _First1;
		_In2_tiles[0] = _First2;
		_Action_tiles[0] = _Actions.begin();
		for (int _I = 1; _I < _Mybase::_Ntiles; ++_I)
			{	// add a tile
			_FwdIt1 _Iter = _Bounded_next(_In1_tiles[_I - 1], _Last1, _Sz);
			if (_Iter != _Last1)
				{	// add new tile
				_In1_tiles[_I] = upper_bound(_Iter, _Last1, *_Iter, _Pred);
				_In2_tiles[_I] = upper_bound(_In2_tiles[_I - 1], _Last2, *_Iter, _Pred);
				}
			else
				{	// at end; add empty tile
				_In1_tiles[_I] = _Last1;
				_In2_tiles[_I] = _Last2;
				}
			_Action_tiles[_I] = _Action_tiles[_I - 1]
				+ _STD distance(_In1_tiles[_I - 1], _In1_tiles[_I])
				+ _STD distance(_In2_tiles[_I - 1], _In2_tiles[_I]);
			}
		_In1_tiles[_Mybase::_Ntiles] = _Last1;
		_In2_tiles[_Mybase::_Ntiles] = _Last2;
		_Action_tiles[_Mybase::_Ntiles] = _Actions.end();
		}
	};

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Do_set_union_par(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _First3,
	_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff;
	_Diff _Count = _STD distance(_First1, _Last1) + _STD distance(_First2, _Last2);
	typedef _Set_dual_selection_payload<_FwdIt1, _FwdIt2, _FwdIt3, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1,
		_First2, _Last2,
		_First3,
		_Pred,
		_Exec,
		true);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Do_set_union(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _First3,
	_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Do_set_union_par(_First1, _Last1,
			_First2, _Last2, _First3, _Pred, _Exec));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Do_set_union(
	_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _First3,
	_Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
	return (_STD set_union(_First1, _Last1,
		_First2, _Last2, _First3, _Pred));
	_CATCH_PAR_END
	return (_First3);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_union(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_Do_set_union(_First1, _Last1,
		_First2, _Last2, _Dest, _Pred,
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_union
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_union(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_union(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_union(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_union(_Exec, _First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_intersection WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	// validate _Dest and copy equivalent
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First1++;
			++_First2;
			}
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_intersection(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	return (_Set_intersection2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_intersection(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE CLASS _Set_selection_payload
template<class _FwdIt1,
	class _FwdIt2,
	class _RanIt,
	class _Pr>
struct _Set_selection_payload
	: _Payload_base<typename std::iterator_traits<_RanIt>::difference_type>
	{	// payload for set_intersection and set_difference
	typedef _RanIt _Result_type;
	typedef _Result_type _Tile_result_type;
	typedef _Payload_base<
		typename std::iterator_traits<_FwdIt1>::difference_type> _Mybase;
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff;
	typedef _Triple_range<_FwdIt1, _FwdIt2, _RanIt> _Range_type;

	template<class _Diff2>
	_Set_selection_payload(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff _Count1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff2 _Count2,
		_RanIt _Dest, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_Exec, _Count1),
		_In1_tiles(_Mybase::_Ntiles + 1, _First1),
		_In2_tiles(_Mybase::_Ntiles + 1, _First2),
		_Out_tiles(_Mybase::_Ntiles + 1, _Dest),
		_Pred(_P), _Block_size(_Count1 / _Mybase::_Ntiles)
		{	// construct from three ranges and predicate
		_Make_tiles(_First1, _Last1, _Count1, _First2, _Last2, _Count2, _Dest);
		}

	void _Apply(_Range_type _Range)
		{	// perform function for each element in subrange
		while (_Range._First1 != _Range._Last1 && _Range._First2 != _Range._Last2)
			{	// check a pair of input values
			if (_Pred(*_Range._First1, *_Range._First2))
				{	// *_First1 < *_First2; copy *_First1
				*_Range._First3++ = 1;
				++_Range._First1;
				}
			else if (_Pred(*_Range._First2, *_Range._First1))
				++_Range._First2;
			else
				{	// *_First1 == *_First2; skip both
				*_Range._First3++ = 0;
				++_Range._First1;
				++_Range._First2;
				}
			}
		while (_Range._First1 != _Range._Last1)
			{	// copy remainder of first input range
			*_Range._First3++ = 1;
			++_Range._First1;
			}
		}

	_Range_type _Get_next_tile() const
		{	// return next tile
		int _Index = _Mybase::_Next_index();
		if (_Mybase::_Ntiles <= _Index)
			return (_Make_triple_range(
				_In1_tiles[_Mybase::_Ntiles], _In1_tiles[_Mybase::_Ntiles],
				_In2_tiles[_Mybase::_Ntiles], _In2_tiles[_Mybase::_Ntiles],
				_Out_tiles[_Mybase::_Ntiles], _Out_tiles[_Mybase::_Ntiles],
				_Mybase::_Ntiles));
		else
			return (_Make_triple_range(
				_In1_tiles[_Index], _In1_tiles[_Index + 1],
				_In2_tiles[_Index], _In2_tiles[_Index + 1],
				_Out_tiles[_Index], _Out_tiles[_Index + 1],
				_Index));
		}

	_Result_type _End() const
		{	// return end of output range iterator
		return _Out_tiles[_Mybase::_Ntiles];
		}
private:
	_Dyn_array<_FwdIt1> _In1_tiles;
	_Dyn_array<_FwdIt2> _In2_tiles;
	_Dyn_array<_RanIt> _Out_tiles;
	_Pr _Pred;
	const _Diff _Block_size;

	template<class _Diff2>
	void _Make_tiles(_FwdIt1 _First1, _FwdIt1 _Last1, _Diff _Count1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Diff2 _Count2,
		_RanIt _Dest)
		{	// compute tile bounds
		_In1_tiles[0] = _First1;
		_In2_tiles[0] = _First2;
		_Out_tiles[0] = _Dest;
		for (int _I = 1; _I < _Mybase::_Ntiles; ++_I)
			{	// add a tile
			_In1_tiles[_I] = _STD next(_In1_tiles[_I - 1], _Block_size);
			_In2_tiles[_I] = _STD lower_bound(
				_In2_tiles[_I - 1], _Last2, *_In1_tiles[_I], _Pred);
			_Out_tiles[_I] = _STD next(_Out_tiles[_I - 1], _Block_size);
			}
		_In1_tiles[_Mybase::_Ntiles] = _Last1;
		_In2_tiles[_Mybase::_Ntiles] = _Last2;
		_Out_tiles[_Mybase::_Ntiles] = _Dest + _Count1;
		}
	};

template<class _FwdIt1,
	class _Diff1,
	class _FwdIt2,
	class _Diff2,
	class _RanIt,
	class _Pr>
void _Do_set_selection_par(
	_FwdIt1 _First1, _FwdIt1 _Last1, _Diff1 _Count1,
	_FwdIt2 _First2, _FwdIt2 _Last2, _Diff2 _Count2,
	_RanIt _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Set_selection_payload<_FwdIt1, _FwdIt2, _RanIt, _Pr> _MyPy;
	_MyPy _Payload(_First1, _Last1, _Count1,
		_First2, _Last2, _Count2,
		_Dest, _Pred, _Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr,
	class _Fn1>
_FwdIt3 _Do_set_diff_int_par( _FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Fn1 _Func1, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff1;
	typedef typename _STD iterator_traits<_FwdIt2>::difference_type _Diff2;
	_Diff1 _Count1 = _STD distance(_First1, _Last1);
	_Diff1 _Count2 = _STD distance(_First2, _Last2);
	_Dyn_array<_Diff1> _Copies(_Count1, 0);
	_Do_set_selection_par(_First1, _Last1, _Count1,
		_First2, _Last2, _Count2,
		_Copies.begin(), _Pred, _Exec);
	_Do_transform_inclusive_scan_par(_Copies.begin(), _Copies.end(),
		_Copies.begin(), _Func1, _FUNCTOR(plus, _Copies.begin()), 0, _Exec);
	return (_Do_pack_par(_Copies.begin(), _Copies.end(),
		_First1, _Dest, _Exec));
	}

template<class _Diff>
struct _Complement
	{	// functor to toggle between 1 and 0
	_Diff operator()(_Diff _Val) const
		{	// return toggled value
		return 1 - _Val;
		}
	};

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Do_set_intersection_par( _FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff1;
	return (_Do_set_diff_int_par(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Complement<_Diff1>(), _Pred,
		_Exec));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Set_intersection_par(_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Rechecked(_Dest,
		_Do_set_intersection_par(_First1, _Last1,
			_First2, _Last2,
			_Dest, _Pred,
			_Exec)));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Set_intersection_par(_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD set_intersection(_First1, _Last1,
			_First2, _Last2, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_intersection(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_STD _Set_intersection_par(_First1, _Last1,
		_First2, _Last2, _Dest, _Pred,
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_intersection
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_intersection(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// AND sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD _Set_intersection_par(_First1, _Last1,
		_First2, _Last2, _Dest, _FUNCTOR(less, _First1),
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_difference WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			{	// validate _Dest and copy first
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	// advance both
			++_First1;
			++_First2;
			}
	return (_STD copy(_First1, _Last1, _Dest));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// take set [_First1, _Last1) from [_First2, _Last2), checked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// take set [_First1, _Last1) from [_First2, _Last2), unchecked dest
	return (_Set_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	return (_Set_difference2(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_Unchecked(
		set_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Do_set_difference_par(_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff1;
	return (_Do_set_diff_int_par(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Identity_transform<_Diff1>(), _Pred,
		_Exec));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Set_difference_par(_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Rechecked(_Dest,
		_Do_set_difference_par(_First1, _Last1,
			_First2, _Last2,
			_Dest, _Pred,
			_Exec)));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
_FwdIt3 _Set_difference_par(_FwdIt1 _First1, _FwdIt1 _Last1,
	_FwdIt2 _First2, _FwdIt2 _Last2,
	_FwdIt3 _Dest, _Pr _Pred,
	execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD set_difference(_First1, _Last1,
			_First2, _Last2, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);	// to quiet diagnostics
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_difference(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using _Pred
	return (_STD _Set_difference_par(_First1, _Last1,
		_First2, _Last2, _Dest, _Pred,
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_difference
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using operator<
	return (_STD set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// take set [_First2, _Last2) from [_First1, _Last1), array dest
	return (_STD set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		_FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_difference(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// take set [_First2, _Last2) from [_First1, _Last1), using operator<
	return (_STD set_difference(_Exec, _First1, _Last1,
		_First2, _Last2, _Dest, _FUNCTOR(less, _First1)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_symmetric_difference WITH PRED
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			{	// validate _Dest and copy first
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	// validate _Dest and copy second
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	// advance both
			++_First1;
			++_First2;
			}
	_Dest = _STD copy(_First1, _Last1, _Dest);
	return (_STD copy(_First2, _Last2, _Dest));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Set_symmetric_difference(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, true_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), checked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred, false_type)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), unchecked dest
	return (_Set_symmetric_difference(_First1, _Last1,
		_First2, _Last2,
		_Dest, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
	return (_Set_symmetric_difference2(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_Unchecked(
		set_symmetric_difference(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
	_FwdIt3 _Do_set_symmetric_difference_par(
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2,
		_FwdIt3 _First3,
		_Pr _Pred,
	execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef typename _STD iterator_traits<_FwdIt1>::difference_type _Diff;
	typedef _Set_dual_selection_payload<_FwdIt1, _FwdIt2, _FwdIt3, _Pr> _MyPy;

	_Diff _Count = _STD distance(_First1, _Last1)
		+ _STD distance(_First2, _Last2);
	_MyPy _Payload(_First1, _Last1,
		_First2, _Last2,
		_First3,
		_Pred,
		_Exec);
	_Master_task<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
	_FwdIt3 _Do_set_symmetric_difference(
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2,
		_FwdIt3 _First3,
		_Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Do_set_symmetric_difference_par(_First1, _Last1,
		_First2, _Last2, _First3, _Pred, _Exec));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _FwdIt3,
	class _Pr>
	_FwdIt3 _Do_set_symmetric_difference(
		_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2,
		_FwdIt3 _Dest,
		_Pr _Pred,
		execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
	return (_STD set_symmetric_difference(_First1, _Last1,
		_First2, _Last2, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);
	}

template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_symmetric_difference(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using _Pred
	return (_Do_set_symmetric_difference(_First1, _Last1,
		_First2, _Last2, _Dest, _Pred,
		_GET_POLICY3(_First1, _First2, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION set_symmetric_difference
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, _FUNCTOR(less, _First1)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	// XOR sets [_First1, _Last1) and [_First2, _Last2), array dest
	return (_STD set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, _FUNCTOR(less, _First1)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _InIt1,
	class _InIt2,
	class _OutIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_OutIt set_symmetric_difference(_Policy&& _Exec,
		_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	// OR sets [_First1, _Last1) and [_First2, _Last2), using operator<
	return (_STD set_symmetric_difference(_Exec, _First1, _Last1,
		_First2, _Last2, _Dest, _FUNCTOR(less, _First1)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION max_element WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN_17 _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_DEBUG_LT_PRED(_Pred, *_Found, *_First))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Max_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Max_element_payload
template<class _FwdIt,
	class _Pr>
	struct _Max_element_payload
		: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
			_Init_value_helper<_Tile_result<_FwdIt> >
	{	// payload for parallel max_element
	typedef _FwdIt _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Max_element_payload(_FwdIt _First, _FwdIt _Last, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
		_Init_value_helper<_Tile_result<_FwdIt> >(
			_Tile_result_type(_First, (unsigned int)(-1))),
		_Pred(_P)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Max_element(_Range._First, _Range._Last, _Pred),
			_Range._Index);
		return (_Reduce(_Res, _Previous));
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Pred(*(_Lhs._Value), *(_Rhs._Value)) ? _Rhs
			: _Pred(*(_Rhs._Value), *(_Lhs._Value)) ? _Lhs
			: _Rhs._Index < _Lhs._Index ? _Rhs : _Lhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_max_element_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Do_max_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Max_element_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Max_element_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First, _Do_max_element_par(
		_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec)));
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD max_element(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt max_element(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find largest element, using _Pred
	return (_Max_element_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION max_element
template<class _FwdIt> inline
	_CONST_FUN _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	// find largest element, using operator<
	return (_STD max_element(_First, _Last, _FUNCTOR(less, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt max_element(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// find largest element, using operator<
	return (_Max_element_par(_First, _Last, _FUNCTOR(less, _First),
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION min_element WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN_17 _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_DEBUG_LT_PRED(_Pred, *_First, *_Found))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Min_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Min_element_payload
template<class _FwdIt,
	class _Pr>
	struct _Min_element_payload
		: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
			_Init_value_helper<_Tile_result<_FwdIt> >
	{	// payload for parallel min_element
	typedef _FwdIt _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Min_element_payload(_FwdIt _First, _FwdIt _Last, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
		_Init_value_helper<_Tile_result<_FwdIt> >(
			_Tile_result_type(_First, (unsigned int)(-1))), _Pred(_P)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Min_element(_Range._First, _Range._Last, _Pred),
			_Range._Index);
		return (_Reduce(_Res, _Previous));
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Pred(*(_Lhs._Value), *(_Rhs._Value)) ? _Lhs
			: _Pred(*(_Rhs._Value), *(_Lhs._Value)) ? _Rhs
			: _Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_min_element_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Do_min_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Min_element_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Min_element_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Do_min_element_par(
			_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec)));
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD min_element(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt min_element(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest element, using _Pred
	return (_Min_element_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION min_element
template<class _FwdIt> inline
	_CONST_FUN _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest element, using operator<
	return (_STD min_element(_First, _Last, _FUNCTOR(less, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt min_element(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// find smallest element, using operator<
	return (_Min_element_par(_First, _Last, _FUNCTOR(less, _First),
		_GET_POLICY(_First, _Exec)));
	}
 #endif /* _HAS_CPP17 */

 #if _HAS_CPP11
		// TEMPLATE FUNCTION minmax_element WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN_17 pair<_FwdIt, _FwdIt>
		_Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	pair<_FwdIt, _FwdIt> _Found(_First, _First);
	if (_First != _Last)
		for (; ++_First != _Last; )
			{	// process one or two elements
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	// process last element
				if (_DEBUG_LT_PRED(_Pred, *_First, *_Found.first))
					_Found.first = _First;
				else if (!_DEBUG_LT_PRED(_Pred, *_First, *_Found.second))
					_Found.second = _First;
				}
			else
				{	// process next two elements
				if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
					{	// test _Next for new smallest
					if (_DEBUG_LT_PRED(_Pred, *_Next, *_Found.first))
						_Found.first = _Next;
					if (!_DEBUG_LT_PRED(_Pred, *_First, *_Found.second))
						_Found.second = _First;
					}
				else
					{	// test _First for new smallest
					if (_DEBUG_LT_PRED(_Pred, *_First, *_Found.first))
						_Found.first = _First;
					if (!_DEBUG_LT_PRED(_Pred, *_Next, *_Found.second))
						_Found.second = _Next;
					}
				_First = _Next;
				}
			}
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_CONST_FUN pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Minmax_element_payload
template<class _FwdIt,
	class _Pr>
	struct _Minmax_element_payload
		: _Payload_base_single_range<_Tiled_range<_FwdIt> >,
			_Init_value_helper<_Tile_result2<std::pair<_FwdIt, _FwdIt> > >
	{	// payload for parallel min_max_element
	typedef std::pair<_FwdIt, _FwdIt> _Result_type;
	typedef _Tile_result2<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<_Tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Minmax_element_payload(_FwdIt _First, _FwdIt _Last, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, _Exec),
		_Init_value_helper<_Tile_result2<std::pair<_FwdIt, _FwdIt> > >(
			_Tile_result_type(_Result_type(_First, _First), 0, 0)),
		_Pred(_P)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(
			_Minmax_element(_Range._First, _Range._Last, _Pred), _Range._Index, _Range._Index);
		return (_Reduce(_Res, _Previous));
		}

	_Tile_result_type _Reduce(_Tile_result_type _Lhs, _Tile_result_type _Rhs)
		{	// combine values from subranges
		if (_Pred(*_Rhs._Value.first, *_Lhs._Value.first))
			{	// rhs < lhs, select rhs
			_Lhs._Value.first = _Rhs._Value.first;
			_Lhs._Index_first = _Rhs._Index_first;
			}
		else if (_Pred(*_Lhs._Value.first, *_Rhs._Value.first))
			;
		else if (_Rhs._Index_first < _Lhs._Index_first)
			{	// equal, select leftmost
			_Lhs._Value.first = _Rhs._Value.first;
			_Lhs._Index_first = _Rhs._Index_first;
			}

		if (_Pred(*_Lhs._Value.second, *_Rhs._Value.second))
			{	// rhs > lhs, select rhs
			_Lhs._Value.second = _Rhs._Value.second;
			_Lhs._Index_second = _Rhs._Index_second;
			}
		else if (_Pred(*_Rhs._Value.second, *_Lhs._Value.second))
			;
		else if (_Lhs._Index_second < _Rhs._Index_second)
			{	// equal, select rightmost
			_Lhs._Value.second = _Rhs._Value.second;
			_Lhs._Index_second = _Rhs._Index_second;
			}

		return (_Lhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_minmax_element_par
template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
	_Do_minmax_element_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Minmax_element_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Minmax_element_par
template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element_par(
			_FwdIt _First, _FwdIt _Last, _Pr _Pred,
			execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
		_Do_minmax_element_par(
			_Unchecked(_First), _Unchecked(_Last), _Pred, _Exec));
	return (pair<_FwdIt, _FwdIt>(
		_Rechecked(_First, _Ans.first),
		_Rechecked(_Last, _Ans.second)));
	}

template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element_par(
			_FwdIt _First, _FwdIt _Last, _Pr _Pred,
			execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD minmax_element(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (pair<_FwdIt, _FwdIt>(_First, _Last));	// to quiet diagnostics
	}

template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_Policy&& _Exec,
			_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find smallest and largest elements, using _Pred
	return (_Minmax_element_par(_First, _Last, _Pred, _Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION minmax_element
template<class _FwdIt> inline
	_CONST_FUN pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last)
	{	// find smallest and largest elements, using operator<
	return (_STD minmax_element(_First, _Last, _FUNCTOR(less, _First)));
	}
 #endif /* _HAS_CPP11 */

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_Policy&& _Exec,
			_FwdIt _First, _FwdIt _Last)
	{	// find smallest and largest elements, using operator<
	return (_Minmax_element_par(_First, _Last, _FUNCTOR(less, _First), _Exec));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION max
template<class _Ty> inline
	_CONST_FUN const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
	{	// return larger of _Left and _Right
	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);
	}

template<class _Ty> inline
	_CONST_FUN1 _Ty (max)(_XSTD initializer_list<_Ty> _Ilist)
	{	// return leftmost/largest
	const _Ty *_Found = _Ilist.begin();	// list must be non-empty
	for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
		if (_DEBUG_LT(*_Found, *_Next))
			_Found = _Next;
	return (*_Found);
	}

		// TEMPLATE FUNCTION max WITH PRED
template<class _Ty,
	class _Pr> inline
	_CONST_FUN const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
	{	// return larger of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Left, _Right) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
	_CONST_FUN1 _Ty (max)(_XSTD initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	// return leftmost/largest
	const _Ty *_Found = _Ilist.begin();	// list must be non-empty
	for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
		if (_DEBUG_LT_PRED(_Pred, *_Found, *_Next))
			_Found = _Next;
	return (*_Found);
	}

		// TEMPLATE FUNCTION min
template<class _Ty> inline
	_CONST_FUN const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
	{	// return smaller of _Left and _Right
	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);
	}

template<class _Ty> inline
	_CONST_FUN1 _Ty (min)(_XSTD initializer_list<_Ty> _Ilist)
	{	// return leftmost/smallest
	const _Ty *_Found = _Ilist.begin();	// list must be non-empty
	for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
		if (_DEBUG_LT(*_Next, *_Found))
			_Found = _Next;
	return (*_Found);
	}

		// TEMPLATE FUNCTION min WITH PRED
template<class _Ty,
	class _Pr> inline
	_CONST_FUN const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
	{	// return smaller of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Right, _Left) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
	_CONST_FUN1 _Ty (min)(_XSTD initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	// return leftmost/smallest
	const _Ty *_Found = _Ilist.begin();	// list must be non-empty
	for (const _Ty *_Next = _Found; _Next != _Ilist.end(); ++_Next)
		if (_DEBUG_LT_PRED(_Pred, *_Next, *_Found))
			_Found = _Next;
	return (*_Found);
	}

		// TEMPLATE FUNCTION minmax

 #if __EDG__ || _GCC0X	/* compiler test */
  #define _MINMAX_PAIR(ty)	pair<const ty&, const ty&>

 #else /* __EDG__ etc. */
  #define _MINMAX_PAIR(ty)	pair<const ty, const ty>
 #endif /* __EDG__ etc. */

template<class _Ty> inline
	_CONST_FUN _MINMAX_PAIR(_Ty)
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Right < _Left
		? _MINMAX_PAIR(_Ty)(_Right, _Left)
		: _MINMAX_PAIR(_Ty)(_Left, _Right));
	}

template<class _Ty> inline
	_CONST_FUN1 pair<_Ty, _Ty> minmax(_XSTD initializer_list<_Ty> _Ilist)
	{	// return {leftmost/smallest, rightmost/largest}
	pair<const _Ty *, const _Ty *> _Res = _STD minmax_element(
		_Ilist.begin(), _Ilist.end());
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		// TEMPLATE FUNCTION minmax WITH PRED
template<class _Ty,
	class _Pr> inline
	_CONST_FUN _MINMAX_PAIR(_Ty)
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Pred(_Right, _Left)
		? _MINMAX_PAIR(_Ty)(_Right, _Left)
		: _MINMAX_PAIR(_Ty)(_Left, _Right));
	}

template<class _Ty,
	class _Pr> inline
	_CONST_FUN1 pair<_Ty, _Ty> minmax(_XSTD initializer_list<_Ty> _Ilist,
		_Pr _Pred)
	{	// return {leftmost/smallest, rightmost/largest}
	pair<const _Ty *, const _Ty *> _Res = _STD minmax_element(
		_Ilist.begin(), _Ilist.end(), _Pred);
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		// TEMPLATE FUNCTION clamp WITH PRED
template<class _Ty,
	class _Pr> inline
	_CONST_FUNX const _Ty& clamp(const _Ty& _Val,
		const _Ty& _First, const _Ty& _Last, _Pr _Pred)
	{	// return closest value to _Val in [_First, _Last] using _Pred
	if (_Pred(_Val, _Last))
		return (_Pred(_Val, _First) ? _First : _Val);
	else
		return (_Pred(_Last, _Val) ? _Last : _Val);
	}

 #if _HAS_CPP17
template<class _Policy,
	class _Ty,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	const _Ty& clamp(_Policy&& _Exec,
		const _Ty& _Val, const _Ty& _First, const _Ty& _Last, _Pr _Pred)
	{	// return closest value to _Val in [_First, _Last] using _Pred
	return (_STD clamp(_Val, _First, _Last, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION clamp
template<class _Ty> inline
	_CONST_FUNX const _Ty& clamp(const _Ty& _Val,
		const _Ty& _First, const _Ty& _Last)
	{	// return closest value to _Val in [_First, _Last] using operator<
	if (_Val < _Last)
		return (_Val < _First ? _First : _Val);
	else
		return (_Last < _Val ? _Last : _Val);
	}

 #if _HAS_CPP17
template<class _Policy,
	class _Ty,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	const _Ty& clamp(_Policy&& _Exec,
		const _Ty& _Val, const _Ty& _First, const _Ty& _Last)
	{	// return closest value to _Val in [_First, _Last] using operator<
	return (_STD clamp(_Val, _First, _Last));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION copy_if
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	// validate _Dest and copy
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, true_type)
	{	// copy each satisfying _Pred, checked dest
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred, false_type)
	{	// copy each satisfying _Pred, unchecked dest
	return (_Copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	// copy each satisfying _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *copy_if(_InIt _First, _InIt _Last, _OutTy (&_Dest)[_OutSize],
		_Pr _Pred)
	{	// copy each satisfying _Pred, array dest
	return (_Unchecked(
		_STD copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
		// TEMPLATE FUNCTION _Do_copy_if_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr>
	_FwdIt2 _Do_copy_if_par(
		_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
			_Pr _Pred,
			execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	return (_Do_conditional_copy(_First1, _Last1, _First2, _Pred,
		_STD distance(_First1, _Last1), _Exec));
	}

		// TEMPLATE FUNCTION _Copy_if_par
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt2 _Copy_if_par(
		_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE_PTR(_First1, _Last1, _First2);
	_DEBUG_POINTER_IF(_First1 != _Last1, _Pred);
	return (_Rechecked(_First2,
		_Do_copy_if_par(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred, _Exec)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if_par(
		_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred,
		execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD copy_if(_First, _Last, _Dest, _Pred));
	_CATCH_PAR_END
	return (_Dest);
	}

template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Pr,
	class = typename enable_if<is_execution_policy<decay_t<_Policy> >::value,
		void>::type> inline
	_OutIt copy_if(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	// copy each satisfying _Pred
	return (_Copy_if_par(_First, _Last, _Dest, _Pred,
		_GET_POLICY2(_First, _Dest, _Exec)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION remove_copy_if
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			{	// validate _Dest and store
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		true_type)
	{	// copy omitting each element satisfying _Pred, checked dest
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred,
		false_type)
	{	// copy omitting each element satisfying _Pred, unchecked dest
	return (_Remove_copy_if(_First, _Last,
		_Dest, _Pred));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	// copy omitting each element satisfying _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *remove_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	// copy omitting each element satisfying _Pred, array dest
	return (_Unchecked(
		_STD remove_copy_if(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Pr,
	class = typename enable_if<is_execution_policy<decay_t<_Policy> >::value,
		void>::type> inline
	_OutIt remove_copy_if(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred)
	{	// copy omitting each matching _Val
	return (_STD copy_if(_Exec, _First, _Last, _Dest, _Make_negation(_Pred)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION remove_copy
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	for (; _First != _Last; ++_First)
		if (!(*_First == _Val))
			{	// validate _Dest and store
			_DEBUG_POINTER(_Dest);
			*_Dest++ = *_First;
			}
	return (_Dest);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		true_type)
	{	// copy omitting each matching _Val, checked dest
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val,
		false_type)
	{	// copy omitting each matching _Val, unchecked dest
	return (_Remove_copy(_First, _Last,
		_Dest, _Val));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Val,
		_Is_checked(_Dest)));
	}

template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *remove_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Val)
	{	// copy omitting each matching _Val, array dest
	return (_Unchecked(
		_STD remove_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Val)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP17
template<class _Policy,
	class _InIt,
	class _OutIt,
	class _Ty,
	class = typename enable_if<is_execution_policy<decay_t<_Policy> >::value,
		void>::type> inline
	_OutIt remove_copy(_Policy&& _Exec,
		_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val)
	{	// copy omitting each matching _Val
	return (_STD remove_copy_if(_Exec, _First, _Last, _Dest, _Make_match_pred(_Val)));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTION next_permutation WITH PRED
template<class _BidIt,
	class _Pr> inline
	bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// permute and test for pure ascending, using _Pred
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	// find rightmost element smaller than successor
		_BidIt _Next1 = _Next;
		if (_DEBUG_LT_PRED(_Pred, *--_Next, *_Next1))
			{	// swap with rightmost element that's smaller, flip suffix
			_BidIt _Mid = _Last;
			for (; !_DEBUG_LT_PRED(_Pred, *_Next, *--_Mid); )
				;
			_STD iter_swap(_Next, _Mid);
			_STD reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	// pure descending, flip all
			_STD reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// permute and test for pure ascending, using _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION next_permutation
template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	// permute and test for pure ascending, using operator<
	return (_STD next_permutation(_First, _Last, _FUNCTOR(less, _First)));
	}

		// TEMPLATE FUNCTION prev_permutation WITH PRED
template<class _BidIt,
	class _Pr> inline
	bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// reverse permute and test for pure descending, using _Pred
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	// find rightmost element not smaller than successor
		_BidIt _Next1 = _Next;
		if (_DEBUG_LT_PRED(_Pred, *_Next1, *--_Next))
			{	// swap with rightmost element that's not smaller, flip suffix
			_BidIt _Mid = _Last;
			for (; !_DEBUG_LT_PRED(_Pred, *--_Mid, *_Next); )
				;
			_STD iter_swap(_Next, _Mid);
			_STD reverse(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	// pure ascending, flip all
			_STD reverse(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	// reverse permute and test for pure descending, using _Pred
	_DEBUG_RANGE_PTR(_First, _Last, _Pred);
	return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		// TEMPLATE FUNCTION prev_permutation
template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	// reverse permute and test for pure descending, using operator<
	return (_STD prev_permutation(_First, _Last, _FUNCTOR(less, _First)));
	}

 #if _HAS_CPP11
		// TEMPLATE FUNCTIONS is_heap AND is_heap_until WITH PRED
template<class _RanIt,
	class _Diff,
	class _Pr> inline
	_RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *)
	{	// find extent of range that is a heap ordered by _Pred
	_Diff _Size = _Last - _First;

	if (2 <= _Size)
		for (_Diff _Off = 0; ++_Off < _Size; )
			if (_DEBUG_LT_PRED(_Pred, *(_First + (_Off - 1) / 2),
				*(_First + _Off)))
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt,
	class _Pr>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// find extent of range that is a heap ordered by _Pred
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(2 <= _Last - _First, _Pred);
	return (_Rechecked(_First,
		_Is_heap_until(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Dist_type(_First))));
	}

template<class _RanIt,
	class _Pr>
	bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	return (_STD is_heap_until(_First, _Last, _Pred) == _Last);
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool is_heap(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	return (_STD is_heap(_First, _Last, _Pred));
	}

template<class _Policy,
	class _RanIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_RanIt is_heap_until(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	// test if range is a heap ordered by _Pred
	return (_STD is_heap_until(_First, _Last, _Pred));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTIONS is_heap AND is_heap_until
template<class _RanIt>
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	// find extent of range that is a heap ordered by operator<
	return (_STD is_heap_until(_First, _Last, _FUNCTOR(less, _First)));
	}

template<class _RanIt>
	bool is_heap(_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	return (_STD is_heap(_First, _Last, _FUNCTOR(less, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _RanIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool is_heap(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	return (_STD is_heap(_First, _Last));
	}

template<class _Policy,
	class _RanIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_RanIt is_heap_until(_Policy&& _Exec,
		_RanIt _First, _RanIt _Last)
	{	// test if range is a heap ordered by operator<
	return (_STD is_heap_until(_First, _Last));
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTIONS is_sorted AND is_sorted_until WITH PRED
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
				return (_Next);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER_IF(_First != _Last && _STD next(_First) != _Last, _Pred);
	return (_Rechecked(_First,
		_Is_sorted_until(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _FwdIt,
	class _Pr> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// test if range is ordered by predicate
	return (_STD is_sorted_until(_First, _Last, _Pred) == _Last);
	}

 #if _HAS_CPP17
		// TEMPLATE CLASS _Is_sorted_until_payload
template<class _FwdIt,
	class _Pr>
	struct _Is_sorted_until_payload
		: _Payload_base_single_range<_Overlapping_tiled_range<_FwdIt> >,
			_Init_value_helper<_Tile_result<_FwdIt> >
	{	// payload for parallel is_sorted and is_sorted_until
	typedef _FwdIt _Result_type;
	typedef _Tile_result<_Result_type> _Tile_result_type;
	typedef _Payload_base_single_range<_Overlapping_tiled_range<_FwdIt> > _Mybase;
	typedef typename _Mybase::_Range_type _Range_type;

	_Is_sorted_until_payload(_FwdIt _First, _FwdIt _Last, _Pr _P,
		execution::_Parallel_policy& _Exec)
		: _Mybase(_First, _Last, 1, _Exec),
			_Init_value_helper<_Tile_result<_FwdIt> >(
				_Tile_result_type(_Last, (unsigned int)(-1))), _Pred(_P)
		{	// construct with iterator pair, predicate, and policy
		}

	_Tile_result_type _Apply(_Range_type _Range, _Tile_result_type _Previous)
		{	// perform function for each element in subrange
		_Tile_result_type _Res(_Is_sorted_until(
			_Range._First, _Range._Last, _Pred), _Range._Index);
		return (this->_Maybe_short_circuit(_Res, _Range._Last, _Previous));
		}

	static _Tile_result_type _Reduce(_Tile_result_type _Lhs,
		_Tile_result_type _Rhs)
		{	// combine values from subranges
		return (_Lhs._Index < _Rhs._Index ? _Lhs : _Rhs);
		}

	_Result_type _Get(_Tile_result_type _Res) const
		{	// extract result
		return _Res._Value;
		}

	_Pr _Pred;
	};

		// TEMPLATE FUNCTION _Do_is_sorted_until_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Do_is_sorted_until_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	typedef _Is_sorted_until_payload<_FwdIt, _Pr> _MyPy;
	_MyPy _Payload(_First, _Last, _Pred, _Exec);
	_Master_task_with_result<_MyPy> _Master(_Payload);
	_Master._Launch();
	return (_Master._Get());
	}

		// TEMPLATE FUNCTION _Is_sorted_until_par
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until_par(
		_FwdIt _First, _FwdIt _Last,
		_Pr _Pred,
		execution::_Parallel_policy _Exec)
	{	// perform function in parallel
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Do_is_sorted_until_par(_Unchecked(_First), _Unchecked(_Last),
			_Pred, _Exec)));
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until_par(
		_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		execution::sequenced_policy)
	{	// perform function sequentially
	_TRY_BEGIN
		return (_STD is_sorted_until(_First, _Last, _Pred));
	_CATCH_PAR_END
	return (_First);
	}

		// TEMPLATE FUNCTIONS PARALLEL is_sorted_until, is_sorted WITH PRED
template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt is_sorted_until(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	return (_Is_sorted_until_par(_First, _Last, _Pred,
		_GET_POLICY(_First, _Exec)));
	}

template<class _Policy,
	class _FwdIt,
	class _Pr,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool is_sorted(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	// find extent of range that is ordered by predicate
	return (_STD is_sorted_until(_Exec, _First, _Last, _Pred) == _Last);
	}
 #endif /* _HAS_CPP17 */

		// TEMPLATE FUNCTIONS is_sorted AND is_sorted_until
template<class _FwdIt> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	// find extent of range that is ordered by operator<
	return (_STD is_sorted_until(_First, _Last, _FUNCTOR(less, _First)));
	}

template<class _FwdIt> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	// test if range is ordered by operator<
	return (_STD is_sorted(_First, _Last, _FUNCTOR(less, _First)));
	}

 #if _HAS_CPP17
template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	_FwdIt is_sorted_until(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// find extent of range that is ordered by operator<
	return (_STD is_sorted_until(_Exec, _First, _Last, _FUNCTOR(less, _First)));
	}

template<class _Policy,
	class _FwdIt,
	class = enable_if_t<is_execution_policy<decay_t<_Policy> >::value,
		void> > inline
	bool is_sorted(_Policy&& _Exec,
		_FwdIt _First, _FwdIt _Last)
	{	// test if range is ordered by operator<
	return (_STD is_sorted(_Exec, _First, _Last, _FUNCTOR(less, _First)));
	}

		// TEMPLATE FUNCTION search
template<class _FwdIt,
	class _Searcher>
	_FwdIt search(_FwdIt _First, _FwdIt _Last,
		const _Searcher& _Search)
	{	// search with _Searcher object
	return (_Search(_First, _Last));
	}

		// TEMPLATE FUNCTION sample
template<class _InIt,
	class _RanIt,
	class _Diff,
	class _Fn1>
	_RanIt _Sample(_InIt _First, _InIt _Last,
		_RanIt _Dest, _Diff _Len, _Fn1& _Func,
			input_iterator_tag, random_access_iterator_tag)
	{	// random access destination
	typedef typename iterator_traits<_RanIt>::difference_type _Mydiff;
	_Mydiff _Size0 = 0;
	_RanIt _Next = _Dest;
	for (; _First != _Last && _Size0 < _Len; ++_Size0)
		*_Next++ = *_First++;	// copy min(_Len, _Last - _First)
	_Mydiff _Size1 = _Size0;
	for (; _First != _Last; ++_First, ++_Size1)
		{	// replace selected items
		_Mydiff _Jx = _Func(_Size1);
		if (_Jx < _Size0)
			_Dest[_Jx] = *_First;	// replace
		}
	return (_Next);
	}

template<class _Mydiff,
	class _Myvalue>
	struct _Pair_compare
	{	// functor for ordering pairs by first element
	typedef pair<_Mydiff, _Myvalue> _Mypair;
	_CONST_FUN bool operator()(const _Mypair& _Left,
		const _Mypair& _Right) const
		{	// apply operator< to operands
		return (_Left.first < _Right.first);
		}
	};

template<class _FwdIt,
	class _OutIt,
	class _Diff,
	class _Fn1>
	_OutIt _Sample(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Diff _Len, _Fn1& _Func,
			forward_iterator_tag, output_iterator_tag)
	{	// non random access destination
	typedef typename iterator_traits<_FwdIt>::difference_type _Mydiff;
	typedef typename iterator_traits<_FwdIt>::value_type _Myvalue;
	typedef pair<_Mydiff, _Myvalue> _Mypair;

	if (_Len <= 0)
		return (_Dest);
	_Mypair *_Heap;
	_TRY_BEGIN
		_Heap = new _Mypair(_Len, _Myvalue());
		_Mydiff _Idx = 0;
		for (; _First != _Last; ++_First)
			{	// add each element to heap, overwriting top as needed
			_Heap[_Idx] = _Mypair(_Func(_Len), *_First++);
			if (_Idx < _Len - 1)
				++_Idx;
			else
				make_heap(&_Heap[0], &_Heap[_Len],
					_Pair_compare<_Mydiff, _Myvalue>());
			}
		while (0 < _Idx)
			*_Dest++ = _Heap[--_Idx].second;
		delete _Heap;
	_CATCH_ALL
		delete _Heap;
	_CATCH_END
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Diff,
	class _Urng>
	_OutIt sample(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Diff _Len, _Urng&& _Func)
	{	// select _Len options from [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	typedef typename remove_reference<_Urng>::type _Urng0;
	_Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
	return (_Sample(_First, _Last, _Dest, _Len, _Rng,
		_Iter_cat(_First), _Iter_cat(_Dest)));
	}
 #endif /* _HAS_CPP17 */

 #endif /* _HAS_CPP11 */

 #if _IS_GHS

 #if defined(__ghs_max_pack_value)
  #pragma pack(pop)
 #endif /* defined(__ghs_max_pack_value) */

 #if defined(__GHS_PRAGMAS)
  #pragma ghs enddata
  #pragma ghs end_cxx_lib_header
 #endif /* defined(__GHS_PRAGMAS) */

#endif /* _IS_GHS */
_STD_END
#endif /* _ALGORITHM_ */

/*
 * Copyright (c) by P.J. Plauger. All rights reserved.
 * Consult your license regarding permissions and restrictions.
 * V8.05/17:1422 */
